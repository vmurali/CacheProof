state n a t : State of processor n for address a at time t
label n a t : The store label corresponding to address a in processor n at time t
deq ch mesg t : Dequeue a message mesg from channel ch at time t
enq ch mesg t : Enqueue a message mesg into channel ch at time t
ReqQ n: Request queue from processor to L1 cache for processor n
RespQ n: Response queue from L1 cache to processor for processor n

Theorem latestValue:
  If a cache n for an address a is in state >= S, then it has a label st such that either
  a) st = initial and there has been no other dequeue of a store 
     request to that address in any of the caches till now OR
  b) st is the label of a store request dequeue to that address in some cache earlier, and there has been
     no other dequeue of a store request to that address in any of the caches
     between dequeuing st and now

  forall n a t, state n a t >= S
    -> ((sl = Initial /\ forall n' t' sl', 0 <= t' <= t -> ~ deq (ReqQ n') (St a sl') t') \/
        (sl <> Initial /\ exists ns ts sl, ts < t /\ deq (ReqQ ns) (label n a t) ts /\
            forall n' t' sl', ts <= t' <= t -> ~ (deq (ReqQ n') (St a sl') t' /\ )))
Proof:
Special case of fullLatestValue

Theorem singleM:
  If a cache is in state M, every other cache is in state I

  forall a t n1 n2, state n1 a t = M
    -> forall n2, state n2 a t = I
Proof:
Since state of a cache is <= state of corresponding directory (by
conservative), and since dirAlwaysCompatible, the states of the caches are also
compatible. So this condition is not violated.

Theorem loadResponse:
  If a load response is enqueued, then
  a) State of that address must be >= S,
  b) a load request for the same address from the same processor
     must be dequeued at the same time (ie in the same event/rule) and
     the load label of the response should match with the request, and
  c) the store label of the response should be the one corresponding to that
     address

  forall n a t, enq (RespQ n) (Resp ld st) t
    -> state n a t >= S /\ deq (ReqQ n) (Ld a ld) t /\ label n a t = st

Theorem storeM:
  If a store requeust is dequeued, then the state of that address must be > S

  forall n a t, deq (ReqQ n) (St a st) t
    -> state n a t > S


Using the above 4 theorems, we can prove the main theorems:

Proving correctResp:
forall rl,
  rl.proc = rl.ldl.proc /\
  rl.ldl.type = Load /\
  ( rl.stl = Initial \/
   (rl.stl <> Initial /\ rl.stl.type = Store /\ rl.ldl.addr = rl.stl.addr))
Proof:
  Using loadResponse, we know that 
  a) The return is from the same processor
  b) The load label has the correct type
  c) the state is at least S
Since state is at least S, theorem latestValue can be applied. So, the store
value will either be Initial or the label will correspond to a store request
dequeued earlier for that address


Proving uniqRespLdLabel:
forall rl1 rl2,
  rl1.ldl = rl2.ldl -> rl1 = rl2
Proof:
By loadResponse theorem, Every time a load response is generated, the
corresponding load request is dequeued, so it can never be looked at again. The
only way they can be the same if they correspond to the same load response

Proving storeAtomicity1:
forall rl,
  rl.stl <> initial /\ rl.proc = rl.stl.proc -> rl.stl.index < rl.ldl.index
Proof:
During a load response enqueue, since state >= S, we can use latestValue
theorem. Since it states that the corresponding store must have occurred
earlier, it has occurred before the corresponding load request (since the load
request occured at the same time according to loadResponse theorem)


Proving storeAtomicity3:
forall rl1 rl2,
  rl1.stl <> Initial /\ rl1.time < rl2.time /\ rl1.addr = rl2.addr /\
    rl1.stl.proc = rl2.stl.proc
      -> rl1.stl.index < rl2.stl.index
During a load response enqueue, since state >= S, we can use latestValue
Lets assume that rl1.stl.index > rl2.stl.index and prove by contradiction.
By latest value theorem, no write has occurred between time of deq of rl2.stl
and rl2.time. But rl1.time < rl2.time and time of deq of rl1.stl is earlier
than rl1.time (again by latestValue theorem). So deq of rl1.stl must have
happened before rl2.time and after time of deq of rl2.stl (because
rl1.stl has higher index than rl2.stl), creating a contradiction.

Proving storeAtomicity2:
forall rl1 rl2 rl3,
  rl1.time < rl2.time < rl3.time /\ rl1.ldl.addr = rl2.ldl.addr = rl3.ldl.addr /\
    rl1.stl <> rl2.stl -> rl1.stl <> rl3.stl
Proof:
During a load response enqueue, since state >= S, we can use latestValue
theorem. 
Case 1: rl1.stl be Initial.
  rl2.stl <> Initial by hypothesis. So some write has occured before rl2.time
(by latestValue theorem).  If rl3.stl = Initial, then no write must have
occured between the rl3.time and 0 (again by latestValue theorem).  But
rl2.time < rl3.time by hypothesis creating a contradiction.
Case 2: rl1.stl <> Initial.
  If rl3.stl = rl1.stl, then no write must have occurred between time of
dequeue of rl3.stl (ie same as rl1.stl) and rl3.time. Also deq time of rl1.stl
< rl1.time (because the store dequeue must have occured earlier according to
latestValue theorem). Similarly deq time of rl2.stl < rl2.time. Now, if time
deq of rl2.stl occured before the time of deq of rl1.stl, then since time of
deq of rl1.stl < rl1.time, time of deq of rl2.stl < time of deq of rl1.stl <
rl1.time < rl2.time. So, a store has occured after rl2.stl, contradicting
theorem latestValue for rl2. Now, if time of deq of rl2.stl occured after time
time of deq of rl1.stl, the same argument can be made for rl2 and rl3 (since
rl3 gets back rl1.stl), leading to the same contradiction.
