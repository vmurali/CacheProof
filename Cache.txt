If you search tag array for responses, you can eliminate MSHR (with just 3 extra bits) - maybe another paper

req from parent:
input: pIndex, lineAddr, to
let present = getPresent(lineAddr)
let index = getIndex(lineAddr)
accept: ~present \/ ~isCReq[index]
if(present)
  State st cstates = case state[index]
                       Coherence {PReq} mshrOld: mshr.getState(mshrOld)
                       State st cstates: State st cstates
  if(st > to)
    let cs = {c|cstates[c] > to)
    if(cs = {})
      case state[index]
        State _ _: state[index] <= State to cstates
      p.resp(Index pIndex, to, dirty[index], line[index])
    else
      let prevMshr = case state[index]
                       Coherence {PReq} mshrOld: PReq mshrOld
                       State _ _: None
      let mshrptr <- mshr.insert(Parent pIndex to cstates prevMshr)
      state[index] <= {CReq} mshrptr
      cs.req(index, lineAddr, to)

handleChildReq(c, cIndex, lineAddr, to, index, inState)
  let State inS cstates = inState
  let cs = {x|cstates[x] > comp(to) /\ x <> c}
  if(inS >= to /\ cs = {})
    let newcstates[x] = x = c? to: cstates[c]
    state[index] <= State inS newcstates
    c.resp(cIndex, cstates[c] -> to, line[index])
  else
    let reqSet = (inS < to? {PReq}: {}) ++ (cs <> {}? {CReq}: {})
    let mshrptr <- mshr.insert(Child c cIndex to getCoh(inState))
    state[index] <= Coherence reqSet mshrptr
    if(inS < to)
      p.req(index, lineAddr, inS -> to)
    if(cs <> {})
      cs.req(index, lineAddr, to)

let invState = State I replicate(I)

req from child:
input: c, cIndex, lineAddr, from -> to
let present = getPresent(lineAddr)
let index = getIndex(lineAddr)
let (State st cstates) = state[index]
accept: ~isPReq[index] /\ ~isCReq[index] /\ (present /\ cstates[c] = from \/ existsReplace[lineAddr])
if(present)
  handleChildReq(c, cIndex, lineAddr, to, index, state[index])
else
  let (replaceLineAddr, replaceIndex) = getReplace[lineAddr]
  let State replaceState replaceCStates = state[replaceIndex]
  if(replaceState = I)
    handleChildReq(c, cIndex, lineAddr, to, replaceIndex, invState)
  else
    let cs = {x|replaceCStates[x] > I}
    if(cs = {})
      p.resp(Voluntary replaceLineAddr, I, dirty[replaceIndex], line[replaceIndex])
      tag[replaceIndex] <= getTag(lineAddr)
      andleChildReq(c, cIndex, lineAddr, to, replaceIndex, invState)
    else
      let mshrptr <- mshr.insert(Child c cIndex to (Replace lineAddr |replaceCStates|))
      state[replaceIndex] <= Coherence {CReq} mshrptr
      cs.req(replaceIndex, replaceLineAddr, I)

resp from parent:
input: index, from -> gotTo, lineIn
if(dataFromParent(from, gotTo))
  line[index] <= lineIn
let (Coherence whoState mshrptr) = state[index]
let (Child c cIndex to (CohState st cstates)) = mshr.get(mshrptr)
let cs = {x|cstates[x] > comp(to) /\ x <> c}
if(cs = {})
  let newcstates[x] = x = c? to : cstates[x]
  mshr.remove(mshrptr)
  state[index] <= State gotTo newcstates
  c.resp(cIndex, cstates[c] -> to, lineIn)
else
  state[index] <= Coherence (whoState - {PReq}) mshrptr
  mshr.updateChildCohReplace(mshrptr, CohState gotTo cstates)

resp from child:
input: c, trigger, gotTo, dirtyIn, lineIn
let index = case trigger
              Voluntary lineAddr: getIndex(lineAddr)
              Index index: index
let newdirty = dirtyIn? True: dirty[index]
let newline = dirtyIn? lineIn: line[index]
if(dirtyIn)
  dirty[index] <= True
  line[index] <= lineIn
case state[index]
  State st cstates:
    let newcstates[x] = x = c? gotTo: cstates[x]
    state[index] <= State st newcstates
  Coherence whoState mshrptr:
    case mshr.get(mshrptr)
      Child c0 cIndex to which:
        case which
          Replace lineAddr count:
            let newCount = count - 1;
            if(count = 0)
              mshr.remove(mshrptr)
              let replaceLineAddr = getLineAddr(index)
              p.resp(Voluntary replaceLineAddr, I, newdirty, newline)
              tag[index] <= getTag(lineAddr)
              handleChildReq(c0, cIndex, lineAddr, to, index, invState)
            else
              mshr.updateChildCohReplace(mshrptr, Replace lineAddr newCount)
          CohState st cstates:
            let newcstates[x] = x = c? gotTo: cstates[x]
            let cs = {x|newcstates[x] > comp(to) /\ c0 <> x}
            if(cs = {})
              newWhoState = whoState - {CReq}
              if(newWhoState = {})
                mshr.remove(mshrptr)
                let finalcstates[x] = x = c0? to: newcstates[x]
                state[index] <= State st finalcstates
                c0.resp(cIndex, newcstates[c0] -> to, newLine)
              else
                state[index] <= Coherence newWhoState mshrptr
                mshr.updateChildCohReplace(mshrptr, CohState st newcstates)
            else
              mshr.updateChildCohReplace(mshrptr, CohState st newcstates)
      Parent pIndex to cstates prevMshr:
        let newcstates[x] = x = c? gotTo: cstates[x]
        let cs = {x|newcstates[x] > to}
        if(cs = {})
          mshr.remove(mshrptr)
          case prevMshr
            PReq mshrptr2: state[index] <= Coherence {PReq} mshrptr2
            None: state[index] <= State to newcstates
          p.resp(Index pIndex, to, newdirty, newline)
        else
          mshr.updateParentCStates(mshrptr, newcstates)
