\section{Introduction}
\label{Sec:Introduction}

Shared memory is a common abstraction for distributed systems, as it
provides an easily understood model of interaction. To achieve this
abstraction efficiently, many hardware systems implement \emph{cache
coherence protocols}.

Since the correctness of this abstraction is paramount in the correct
functioning of the system, significant effort is expended in making sure
that the cache coherence engine is correct. In practice, verification proceeds
in two steps. First, a cache coherence protocol is constructed and
verified. This protocol generally directly represents many of
the key concurrent aspects of an implementation (\eg{} reads and
writes to the system are broken into local atomic micro-operations) but
ignores implementation details (\eg{} buffer sizing and memory access
times). Second, once the protocol has been verified, it is handed to
hardware experts who fill in the missing implementation details and
realize it at the Register Transfer Level (RTL) of gates, wires, and
registers, via further breaking down of local micro-operations to
make them realizable in hardware. This effort is not a one-time translation, as
performance properties are not easily estimated; a significant amount of
performance testing is requires to select a good implementation. 

Methodologically, this process is flawed. The guarantees gained from
verifying the protocol have no bearing on the implementation if
hardware designers must do a manual translation to RTL.

Verified protocols are often described via Term Rewrite Systems (TRS),
which apply equational logic to describe systems at an interesting
point on the spectrum between declarative and operational methods.  It
was shown by Dave \etal{}~\cite{DNA:CoherenceImplementation} that such
a verified protocol could be transliterated into
Bluespec~\cite{Bluespec:TFRG}, a hardware description language based
on Guarded Atomic Actions, a restriction of TRS~\cite{Hoe:TCAD}. In
this way one reduces the correctness of the implementation to the
correctness of the protocol, with no need for separate reasoning about
an implementation. While the current Bluespec compiler does not
support some implementation elements that are common in practice
(\eg{} fairness guarantees, atomic actions running over multiple clock
cycles), recent work has provided key insights toward lifting the
restrictions~\cite{DNA:CoherenceImplementation, Karczmarek}.  We
believe that Bluespec and its future evolutions represent a very
promising platform for productive implementation and verification of
hardware components, including cache-coherent shared memories.

Even though the protocol transliteration approach cuts out one
layer of verification effort, it may not be practical in practice.
Design of a hardware system requires many tweaks to reach
optimal performance, since low-level performance details often
can only be found empirically.  Each performance tweak potentially
breaks correctness, or at least breaks the structure of the old
\emph{proof} of correctness, so that a full \emph{reverification}
of correctness is needed in principle. Hardware designers are
unlikely to have the expertise or skill to do each such
verification.  Our motivating question in this paper is, \emph{can
we modularize formal proofs of cache coherence protocols so that
verification experts do the hard work once and for all, and then
hardware designers can instantiate the results to different designs
with much less effort?}

In practice, protocol variants rely on a small set of general ``local
building block'' properties, like guaranteed delivery of messages sent
between processors, or guaranteed state changes in processors upon
receiving certain messages.  These properties are
easily verifiable, since they correspond to a small partition of the
system, for instance a single cache.  The details of how these
properties hold vary depending on the precise design variant. For
instance, the reason why some property holds, like the point-to-point
FIFO ordering for messages transferred between two nodes, depends on
the type of network; the proof will be very different for a mesh
network compared to a point-to-point network.

In this paper, we describe an approach to provide this proof framework
for any particular cache coherence protocol via the example of an
MSI-style protocol.  We also show how it can be extended to other protocols
like MESI and MOESI.  We present a modular proof architecture,
where modification of microarchitectural
aspects of design only necessitates reverification of relatively shallow
local building block properties. Our framework and several instantiations
for it are mechanized in the Coq proof assistant system, providing the
highest levels of formal assurance upon a small trusted code base.
We implemented and verified one particular MSI protocol via an
operational semantics in Coq.

\noindent\textbf{Paper Outline}. In Section~\ref{Sec:Background} we
discuss our notion of correctness for our cache coherence protocol
framework. We describe our MSI protocol example and its implementation
in Section~\ref{Sec:System}. In Sections~\ref{Sec:Safety} and
\ref{Sec:Liveness}, we discuss the structuring of our proof framework and
verification of the base protocol. We show implementation refinements
in Section~\ref{Sec:Refinements} and conclude with a general
discussion of the applicability of our technique.
