\section{Introduction}
\label{sec:Introduction}

Shared memory is a common abstraction for distributed systems as it
provides an easily understood model of interaction. To achieve this
abstraction efficiently, many hardware systems implement a cache
coherence implementation. 

Since the correctness of this abstraction is paramount in the correct
functioning of the system, significant effort is placed in making sure
that the cache coherence engine is correct. In practice, this is done
in two steps. First, a cache coherence protocol is constructed and
verified. This protocol generally directly represents many of
the key concurrent aspects of an implementation, \eg{} reads and
writes to the system are broken into local atomic micro-operations, but
ignores implementation details \eg{} buffer sizing and memory access
times. Second, once the protocol has been verified it is handed to
hardware experts who fill in the missing implementation details and
realize it at the Register Transfer Level (RTL) of gates, wires, and
registers. This involves further breaking down of local micro-operations to
make it realizable in hardware. This effort is not a one-time translation, as
performance properties are not easily estimated; a significant amount of
performance testing is requires to select a good implementation. 

From a methodological perspective, this two-step process represent a
significant methodological failure. The significant effort of
verification is effectively lost by the concurrent non-trivial tasks
of translation from the protocol representation to a hardware
description and the necessary refinement to add missing implementation
details to the protocol. 

Because verified protocols are often described via Term Rewrite
Systems (TRS). It was shown by Dave
\etal{}~\cite{DNA:CoherenceImplementation} that such a verified
protocol could be transliterated into Bluespec~\cite{Bluespec:TFRG}, a
hardware description language based on Guarded Atomic Actions, a
restriction of TRS~\cite{Hoe:TCAD}. This reduces the correctness of
the implementation to the correctness of the protocol, effectively
removing any implementation bugs. While the current Bluespec compiler
has certain restrictions which limit the expressiveness of certain
operations \eg{} fairness is not guaranteed, atomic actions are always
implemented in a single cycle, work has been done to remove these
restrictions~\cite{DNA:CoherenceImplementation, Karczmarek}.

While better, this approach of protocol transliteration has
flaws. Design of a hardware system requires many tweaks to reach
optimal performance as one cannot practically know the correct
low-level hardware results without evaluating the low-level
representation.  Each of these changes can potentially breaks
correctness and a full reverification of correctness is needed in
principle. As hardware designers are unlikely to have the expertise or
skill to do make this verification, this greatly weakens the ability
to carry over our verification guarantee to the design.

For this approach to be truly viable, designers cannot be handed a
single proof of correctnessof a single design; rather, they need a
proof framework covering any variation of a design that might be of
interest for performance reasons. This would enable implementation
level changes without compromising on the ability to verify
correctness of the design.

In practice, protocol variants rely on a small set of general ``local
building block'' properties, \eg{} messages always get from source to
destination or that the local cache's reaction to receiving a protocol
message results in the appropriate messages being sent, the
appropriate local state being changed \etc{}.  These properties are
easily verifiable since they correspond to a small partition of the
system, for instance a single cache.  The details of how these
properties hold vary depending on the precise design variant. For
instance, the reason why some property holds, like the point-to-point
FIFO ordering for messages transferred between two nodes, depends on
the type of network; the proof will be very different for a mesh
network compared to a point-to-point network.

In this paper, we describe an approach to provide this proof framework
for any particular cache coherence protocol via the example of a
MSI-style protocol and show how it can be extended to other protocols
like MESI and MOESI. We show how the modular structure of the proof
and design can be shared and how modification of microarchitectural
aspects of design directly translates to just reverification of our
local building block properties. We use Coq for our proof
framework. We also show how an atomic-action-based MSI protocol
description can be directly transliterated into an Inductive
definition in Coq, and verify its local building block properties
formally.

\noindent\textbf{Paper Outline}. In Section~\ref{Sec:Background} we
discuss our notion of correctness for our cache coherence protocol
framework. We discuss our MSI protocol example and its implementation
in Section~\ref{Sec:System}. In Section~\ref{Sec:ProofStructure} we discuss
the structuring of our proof framework and verification of the base
protocol. We show implementation refinements in
Section~\ref{Sec:Refinements} and conclude with a general discussion
of the applicability of our technique.
