\section{Introduction}
\label{sec:Introduction}

Shared memory is a common abstraction for distributed systems, as it provides
an easily understood model of interaction. To achieve this abstraction
efficiently, many hardware systems implement \emph{cache coherence protocols}.
Since the correctness of this abstraction is paramount in the correct
functioning of the system, it is imperative to ensure that the cache coherence
protocol implementation is correct.

Formal verification of cache coherence protocols has traditionally been done
using model checking. That family of analyses significantly restricts the size
as well as complexity of the system that has to be verified; most model-checking
based approaches can not handle more than one level of hierarchy. To the best of
our knowledge, the largest system that has been verified using model checking
has only 12 processors~\cite{Chen:2008:VHC:1559300}, in an era when many
observers are predicting mainstream systems with hundreds of processor cores.

Apart from scalability concerns, another downside of model checking
is that it provides no intuition as to why a protocol is correct, if
the model checker successfully proves a protocol. Developing a new protocol
therefore cannot use any intuition that could have been gained from
the first protocol. Moreover, the new protocol has to be verified from scratch.

We propose a theorem-prover based approach for proving cache coherence
protocols. Using this approach eliminates the scalability and complexity
problems faced by model checkers, but the downside is that considerable
laborious effort is needed by verification experts to provide a proof for the
protocol, and the complexity of the protocol directly translates into effort.
Our motivating question in this paper is,
\emph{can we modularize formal proofs of cache coherence protocols so that
verification experts do the hard work once and for all, and then hardware
designers can instantiate the results to different designs with much less
effort?}

While our present approach is not push-button, we have developed a
modular proof strategy, where portions of our proof can be used \emph{as is} to
prove other related but distinct protocols. Moreover, the proof gives
insights on why the protocol works correctly, which can be used to design other
protocols.

The main contribution of this paper is, \textbf{the first verification of a
cache coherence protocol that is parametric over an infinite family of
memory hierarchies}.  Our proof is implemented in the Coq proof assistant and
checked via a very small trusted code base.  We also want to draw attention to
a few key elements of our methodology that should be of interest for future
verifications of this kind, both through literal code reuse and through insights
about key invariants that should generalize across protocols.
\begin{enumerate}
\item We give a \emph{precise formal definition of a cache-coherent system} as one
that obeys \emph{store atomicity}. The definition is abstract in that it does not
rely on any hardware implementation.
\item We provide a \emph{Coq-based proof of the directory-based MSI cache coherence
protocol} with inclusive caches and no silent drops.
\item We present \emph{a set of invariants} that are not restricted to the MSI
protocol but which imply store atomicity. Thus, other protocols will also
satisfy store atomicity as long as they obey the invariants.
\item We present what we believe to be \emph{the key insight behind the
correctness of the MSI protocol}. We believe that this property is true also of
other protocols like MESI, MOSI, and MOESI, enabling reuse of portions of our
MSI proof for their verification.
\end{enumerate}
%In practice, verification proceeds in
%two steps. First, a cache coherence protocol is constructed and verified. This
%protocol generally directly represents many of the key concurrent aspects of an
%implementation (\eg{} reads and writes to the system are broken into local
%atomic micro-operations) but ignores implementation details (\eg{} buffer
%sizing and memory access times). Second, once the protocol has been verified,
%it is handed to hardware experts who fill in the missing implementation details
%and realize it at the Register Transfer Level (RTL) of gates, wires, and
%registers, via further breaking down of local micro-operations to make them
%realizable in hardware. This effort is not a one-time translation, as
%performance properties are not easily estimated; a significant amount of
%performance testing is requires to select a good implementation. 
%
%\adamc{I don't understand what this paragraph is saying.}
%From a methodological perspective, this two-step process leaves much to be
%desired. The significant effort of verification is effectively lost by the
%concurrent non-trivial tasks of translation from the protocol representation to
%a hardware description and the necessary refinement to add missing
%implementation details to the protocol. 

Protocols, post verification, are often described via Term Rewrite
Systems (TRS)~\cite{bezem2003term}, which apply equational logic to
describe systems at an interesting point on the spectrum between
declarative and operational methods.  It was shown by Dave
\etal{}~\cite{DNA:CoherenceImplementation} that such a protocol, after
its verification, can be transliterated into
Bluespec~\cite{Bluespec:TFRG}, a hardware description language based
on Guarded Atomic Actions, a restriction of
TRS~\cite{Hoe:TCAD}. Bluespec specifications can be directly
implemented into efficient hardware. In this way one reduces the
correctness of the implementation to the correctness of the protocol,
with no need for separate reasoning about an implementation. While the
current Bluespec compiler does not support some implementation
elements that are common in practice (\eg{} fairness guarantees,
atomic actions running over multiple clock cycles), recent work has
provided key insights toward lifting the
restrictions~\cite{Karczmarek}. We believe that Bluespec and its
future evolutions represent a very promising platform for productive
implementation of hardware components, including cache-coherent shared
memories, starting from a specification designed to support
verification.

Our model of the MSI protocol
in Coq is described as an inductively defined set of transitions that is
directly translatable into Guarded Atomic Actions. In fact, our Coq-based model
is a direct transliteration of the MSI protocol specified in Bluespec,
ensuring that the final hardware synthesized from the specification is formally
verified.

%Even though the protocol transliteration approach cuts out one
%layer of verification effort, it may not be practical in practice.
%Design of a hardware system requires many tweaks to reach
%optimal performance, since low-level performance details often
%can only be found empirically.  Each performance tweak potentially
%breaks correctness, or at least breaks the structure of the old
%\emph{proof} of correctness, so that a full \emph{reverification}
%of correctness is needed in principle. Hardware designers are
%unlikely to have the expertise or skill to do each such
%verification. 
%
%In practice, protocol variants rely on a small set of general ``local
%building block'' properties, like guaranteed delivery of messages sent
%between processors, or guaranteed state changes in processors upon
%receiving certain messages.  These properties are
%easily verifiable, since they correspond to a small partition of the
%system, for instance a single cache.  The details of how these
%properties hold vary depending on the precise design variant. For
%instance, the reason why some property holds, like the point-to-point
%FIFO ordering for messages transferred between two nodes, depends on
%the type of network; the proof will be very different for a mesh
%network compared to a point-to-point network.

%In this paper, we describe an approach to provide this proof framework
%for any particular cache coherence protocol via the example of an
%MSI-style protocol.  We also show how it can be extended to other protocols
%like MESI and MOESI.  We present a modular proof architecture,
%where modification of microarchitectural
%aspects of design only necessitates reverification of relatively shallow
%local building block properties. Our framework and several instantiations
%for it are mechanized in the Coq proof assistant system, providing the
%highest levels of formal assurance upon a small trusted code base.
%We implemented and verified one particular MSI protocol via an
%operational semantics in Coq.

\noindent\textbf{Paper Outline}. In Section~\ref{Background} we give a
formal definition of a cache-coherent system as one that obeys store atomicity.
We describe memory subsystems as mathematical functions and define store
atomicity as a property of the input/output pairs of the memory subsystem
function. We describe our MSI protocol and its representation as a
transition relation in Coq in Section~\ref{sec:System}. In
Section~\ref{safety} we discuss the structuring of our proof. We
present the invariants that are sufficient to prove store atomicity and give
the key insight that enables these invariants to be proved.
%We discuss some refinements in
%Section~\ref{Sec:Refinements} and conclude with a general discussion
%of the applicability of our technique.

The Coq source code for the definition of store atomicity and the proof of the
MSI protocol can be found in \url{https://github.com/vmurali/CacheProof}.

%\adamc{This might be a good place to include a link to the Coq source code.}
