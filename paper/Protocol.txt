forall a, root.data[a] = Initial

The fields in the struct are in the order they were defined. $t$ denotes the
current time, ie time of execution of the rules.

For channel c, c.first denotes the value sitting at the head of the queue,
c.deq denotes dequeuing the head, and c.enq denotes enqueuing into the channel.
c.notE denotes that the head has a message. We assume infinite buffering in the
channels as mentioned earlier -- so we do not have to check whether a channel
has capacity to send a message

Load request at L1
(proc2C[c].first = <label a Ld idx> /\ c.state[a] >= S) -> {
  c2Proc[c].enq(<label c.data[a] t>)
  proc2C[c].deq
}

Store request at L1
(proc2C[c].first = <label a St idx> /\ c.state[a] = M) -> {
  c.data[a] = label
  c2Proc[c].enq(<label _ t>)
     // Not necessary -- the enq action can be defined differently for stores
  proc2C[c].deq
}

wait: Addr->bool and waits: Addr -> State are new states for each cache denoting whether a cache is waiting for a response from the parent and if so, the upgrade it's waiting for.
dwait: Cache -> Addr -> bool and dwaits: Cache -> Addr -> State: Directory counterparts.

Child sends request
(c.state[a] < x /\ c.wait[a] = false) -> {
  c.wait[a] = true
  c.waits[a] = x
  c2pReq[c].enq(<c.state[a] x a>)
}

Parent p receives request and sends response
(c2pReq[c].first = <y x a>
     /\ (x = M ->
          forall i, parent p i -> i <> c -> p.dstate[i][a] = I)
     /\ (x = S ->
          forall i, parent p i -> i <> c -> p.dstate[i][a] <= S)
     /\ (p.state[a] >= x)
     /\ p.wait[c][a] = false
     /\ p.dstate[c][a] <= y) -> {
  let d = if p.dstate[c][a] = I then p.data[a] else _ in
                         p2c[c].enq(<Resp x a d>)
  p.dstate[c][a] = x
  c2pReq[c].deq
}

Child receives response
(p2c[c].first = <Resp x a d>) -> {
  if(c.wait[a] = true && c.waits[a] <= x)
    c.wait[a] = false
  if(c.state[a] = I)
    c.data[a] = d
  c.state[a] = x
  p2c[c].deq
}

Parent sends request
(p.dstate[c][a] > x /\ p.wait[c][a] = false) -> {
  p.dwait[c][a] = true
  p.dwaits[c][a] = x
  p2c[c].enq(<Req x a _>)
}

Child receives request and sends response
(p2c[c].first = <Req x a> /\ c.state[a] > x
  /\ forall i, parent c i -> c.dstate[i][a] <= x) -> {
  let d = if c.state[a] = M then c.data[a] else _ in
                        c2pResp[c].enq(<c.state[a] x a d>)
  p2c[c].deq
}

Parent receives response
(c2pResp[c].first = <y x a d> /\ p.dstate[c][a] = y) -> {
  if(p.dwait[c][a] = true && p.dwaits[c][a] >= x)
    p.dwait[c][a] = false
  if(p.dstate[c][a] = M)
    p.data[a] = d
  p.dstate[c][a] = x
  c2pResp[c].deq
}

Child sends voluntary response
(c.state[a] > x /\ c.wait[a] = false) -> {
  let d = if c.state[a] = M then c.data[a] else _ in
                        c2pResp[c].enq(<c.state[a] x a d>)
  c.state[a] = x
}

Child receives request and drops
(p2c[c].first = <Req x a _> /\ c.state[a] <= x) -> {
  p2c[c].deq
}
