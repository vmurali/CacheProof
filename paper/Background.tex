\section{Correctness of a Cache Coherence Protocol}
\label{Background}

Before we can discuss our protocol and proof framework, we must first establish
exactly what it means for a cache coherence protocol to be correct. 

Intuitively, the simplest view of shared memory is as an array of addressible
objects in which a single entry can be read or written by one of the many
processors at a time.  In this view, all operations in the system appear to
have a single unique total ordering.

All modern systems have caches between the processor and memory for faster
memory access. It is often also useful to reorder requests from a processor to
the memory to improve performance. For instance, a load may bypass a previous
store to a different location. The \emph{memory consistency model} describes
the semantics of a system in the presence of caches and reorderings.

Most memory consistency models can be partitioned into two
parts~\cite{Arvind-memory-model}: (a) a ``global'' store-atomicity property
stating that for each location/address in memory, every read and write access
to that location, from any processor, occurs in some total order, with
each operation seeing the effects of previous operations and not later ones (in
other words, each location behaves like an atomic register) and (b), a
``local'' reordering restriction between requests to different locations within
each processor. Changing the memory model by modifying the reordering
restrictions will not incur a reverification of the store-atomicity property.

The mechanism employed by the memory subsystem to ensure store-atomicity per
location, in the presence of caches, is known as \emph{cache coherence}. In the
presence of caches, multiple copies of the same address can exist in different
caches. If these copies are written independently, the same address can end up
having different values in different caches, violating the atomic register-like
behavior unless the caches coordinate via a \emph{cache coherence protocol}.

We will now provide the formal definition of store atomicity.

\subsection{Formal Definition of Store Atomicity}
A memory subsystem can be modeled as the following function. Its input is a
potentially infinite set of requests sent by processors in the course of some
full-system execution, and its output is a potentially infinite set of
the responses sent by the memory subsystem processors.

Each input to the memory subsystem is isomorphic to a function
$\reqFn : (Processor \times \mathbb{N}) @-> \Request$, where $\reqFn(p, i)$ models the
$i^{th}$ request issued by processor $p$. An element of the set \Request{} (the
range of \reqFn{}) contains fields (a) address (\addrQ) corresponding to
the request, (b) \desc{} indicating whether the request is a load or a store,
and (c) data (\dataQ) containing the data supplied by the processor for stores.

An output of the memory subsystem is a set \Response{} of exactly the responses generated
in a particular protocol execution.  Each response includes the fields
(a) \labelR, containing a pair from the set
$Processor \times \mathbb{N}$, which is meant to identify a request uniquely, (b)
\dataR, meant to model the data returned from the memory subsystem, and (c)
\timeR{} in $\mathbb{N}$, meant to represent the ``time'' at which
the corresponding request (identified by \labelR) is handled by the memory
subsystem. This last field does not have a counterpart in a real implementation; it is
present solely as a specificational device to capture store atomicity. Since a
request corresponding to a response is identified using the field \labelR, for
notational convenience, we will access the fields of the corresponding request
directly from the response. For instance, $r.\addrQ$ for $r \in \Response$
denotes $(r.\labelR).\addrQ$, \etc

If \reqFn{} is an input to the memory subsystem, and the set \Response{} is the
corresponding output, then the memory subsystem is said to be \textbf{store atomic} if it
obeys Theorem~\fullref{storeAtomicity} defined as follows. We use the word
``response'' to denote an element in the set \Response{}.
%
\begin{defn} (Responses have unique labels.)
\small
\begin{multline*}
\textit{uniqRespLabels} := \forall (r_1, r_2 \in \Response). \;
r_1.\labelR = r_2.\labelR @-> \\ r_1.\timeR = r_2.\timeR \wedge
r_1.\dataR = r_2.\dataR
\end{multline*}
\label{uniqRespLabels}
\end{defn}

\vspace{-.3in}

\begin{defn} (No response can share a \timeR{} value with another store
response for the same address, imposing a total order on stores within an address.)
\small
\begin{multline*}
\textit{uniqStTimes} := 
\forall (r_1, r_2 \in \Response). \;
r_1.\timeR = r_2.\timeR @-> \\
r_1.\addrQ = r_2.\addrQ @->
r_1.\desc = \St @->
r_1.\labelR = r_2.\labelR
\end{multline*}
\label{uniqStTimes}
\end{defn}

\vspace{-.3in}

\begin{defn} (The global ordering of responses to the same processor should not
violate the ordering of the corresponding requests within the processor.)
\small
\begin{multline*}
\textit{localOrdering} :=
\forall (r_1, r_2 \in \Response). \; r_1.\labelR.\fst = r_2.\labelR.\fst @->\\
r_1.\labelR.\snd < r_2.\labelR.\snd @-> r_1.\timeR \le r_2.\timeR
\end{multline*}
\label{localOrdering}
\end{defn}

\vspace{-.3in}

\begin{defn} (If a response to a particular request from a processor exists in the \Response{} set,
then responses for all previous requests from that processor must exist.)
\small
\begin{multline*}
\textit{allPrevious} :=
\forall (r \in \Response). \; \forall i < r.\labelR.\snd. \\
\exists (r' \in \Response). \; r'.\labelR.\fst = r.\labelR.\fst \wedge r'.\labelR.\snd = i
\end{multline*}
\label{allPrevious}
\end{defn}

\vspace{-.3in}

Now we are ready to give the main condition for store atomicity, which states that the
data returned for a load response corresponds to the \emph{last earlier} store
request from any processor that has been handled for that address, \emph{last}
and \emph{earlier} being defined according to the field \timeR{} returned in
the responses.  This proposition is indicated by \textit{lastEarlierValue}$(r)$
for a load request $r$.  In case no store has happened earlier for a particular
address when a load is processed, then the load response returns the initial
value for the address ($\initData(a)$), the whole proposition indicated by
\textit{useInitialValue}$(r)$.
\begin{defn}
\small
\begin{multline*}
\textit{useInitialValue}(r) := r.\dataR = \initData(a) \; \wedge \neg \exists (r' \in \Response). \\
r'.\timeR < r.\timeQ \wedge r'.\addrQ = r.\addrQ \wedge r'.\desc = \St
\end{multline*}
\label{useInitialValue}
\end{defn}

\vspace{-.3in}

\begin{defn}
\small
\begin{multline*}
\textit{lastEarlierValue}(r) := \exists (r_m \in \Response). \; r_m.\dataQ = r.\dataQ \; \wedge 
\\ r_m.\desc = \St \wedge r_m.\addrQ = r.\addrQ \wedge
\neg \exists (r' \in \Response). \\
r_m.\timeR < r'.\timeR < r.\timeQ \wedge r'.\addrQ = r.\addrQ \wedge r'.\desc = \St
\end{multline*}
\label{lastEarlierValue}
\end{defn}

\vspace{-.3in}

Using the above definitions, we can define the store-atomicity theorem as follows:
\begin{thm}\textit{storeAtomicity}:
\small
\begin{multline*}
\textit{uniqRespLabels} \wedge
\textit{uniqStTimes} \wedge \textit{localOrdering} \wedge \textit{allPrevious} \; \wedge \\
(\forall (r \in \Response). \; r.\desc = \Ld \; @-> \\
(\textit{useInitialValue}(r) \vee \textit{lastEarlierValue}(r)))
\end{multline*}
\label{storeAtomicity}
\end{thm}

\vspace{-.3in}

The technical meat of this paper is a framework for proving this store atomicity
property independently of details of memory hierarchies.  In the next section,
we formalize memory hierarchies and a specific nondeterministic algorithm for
generating their possible event traces.
