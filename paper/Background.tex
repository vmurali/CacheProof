\section{Correctness of our Cache Coherence System}

Before we can discuss our protocol framework and it's verification we
must first establish exactly what it means for a system to be
correct. 

Intuitively, the easiest view of shared memory is as a single ported
memory multiplexed amongst the many individual client/processors. In
this view, all operations in the system appear to have a single unique
total ordering. 

While simple, it is often useful for performance to permit some
reorderings. For instance, in the context of a processor with local
store buffer, we may wish to allow store values to bypass subsequent
load requests. In general, any potential reordering may be considered
a valid memory consistency model, though they may result in a stronger
verification requirement.

As part of our design exploration for our concrete protocol example,
we may want to change the memory consistency model. To this end, we
are using the notion of store-atomicity to define our memory
model. Most memory consistency models require that the memory
subsystem obeys the store-atomicity property and as such our design
should be modifiable to any of these designs. 

A store-atomic memory model can be partitioned into two
parts~\cite{Arvind-memory-model}. First, a ``global'' store-atomicity
property stating that for every read and write access to a particular
location in memory occur in some total order with each operation
seeing the effects of previous operations and not later ones. Seconds
a ``local'' reordering restrictions between requests to different
locations within each processor. The advantage of this approach is
that reordering restrictions pertain to reordering requests locally of
the same processor, while the global store-atomicity property is
constant throughout. Thus changing the memory model should not incur a
reverification of the store-atomicity property. For our concrete
protocol example, we will assume that our memory model is weakly
ordered, in that there are inter-address dependencies between
processors.

Now that we have informally discussed the meaning store atomicity, we
can now provide a formal definition.

%% For example, it dictates whether a store request to an address $x$ can
%% be issued to the memory sub-system before a load request to a
%% different address $y$, which was generated by the same processor
%% earlier (\ie load $y$ happened before store $x$ is program order, but
%% the order of issue to memory sub-system is reversed).


%% The mechanism employed by the memory sub-system to ensure store-atomicity per
%% location, in the presence of caches, is known as \emph{cache coherence}. In the
%% absence of caches, since there is exactly one copy of the data for each
%% address, it is easy to ensure cache coherence. The problem comes in the
%% presence of shared caches -- multiple copies of the same address can exist in
%% different caches, and if these locations are independently written, then the
%% same address can end up having different values in two different caches. Each
%% location would no longer behave like an atomic register unless some sort of
%% co-ordination happens between the different caches -- this co-ordination is
%% summed up as the \emph{cache coherence protocol}.

\subsection{Formal definition of store atomicity}

To properly define the interface with between the processor and the
caching system we must fine the request and responses for each
processor.  Figure~\ref{req-resp} shows the
data-type corresponding to a request issued from the processor to the
memory subsystem.  A request contains the address (\addrQ)
corresponding to the request, and a type indicating whether the
request is a load or a store (\desc). In case of a store request, it
also contains data (\dataQ) supplied by the processor for that
address.A response contains a label
(\labelR) to identify the request corresponding to the response. The label
contains a processor name and a position, which uniquely identifies a request.
In the case of a load request, the memory sub-system returns \dataR, the data
returned by the memory subsystem for that address. The memory sub-system also
returns a natural number, \timeR, which is used solely in the definition of
store atomicity, and is not returned in a real system. \timeR{} can be informally
thought to represent the position at which this request has been handled
globally among all the requests issued from all the processors.

We model request of a processor formally with the function
\reqFn. $\reqFn(p, i)$ returns the $i^{th}$ request issued by
processor $p$, \ie{} $\reqFn: (\textit{Processor} * \mathbb{N}) @->
\Request$.  The processor name and the position of the request within
the processor uniquely identifies a request.

\begin{figure}
\centering
\begin{subfigure}{5.5cm}
\begin{tabular}{|lp{4.5cm}|}
\hline
\multicolumn{2}{|c|}{\Request}\\
\hline
\addrQ:& Address associated with the request\\
\desc:& Request type (\Ld{} or \St)\\
\dataQ:& Data associated with a \St{} request\\
\hline
\end{tabular}
\end{subfigure}~~~~
\begin{subfigure}{5.5cm}
\begin{tabular}{|lp{4.5cm}|}
\hline
\multicolumn{2}{|c|}{\Response}\\
\hline
\labelR:& Label identifying the request corresponding to this response\\
\dataR:& Data returned by the memory subsystem for a \Ld{} request\\
\timeR:& Natural number representing global order of (processing) requests\\
\hline
\end{tabular}
\end{subfigure}
\caption{Data types for request and response}
\label{req-resp}
\end{figure}

In the following, a \Response{} set only contains those responses sent by the
memory subsystem.

The responses should obey the following sanity conditions:

\begin{defn} (The labels in the responses are unique. Since \dataR{} field is
irrelevant for store requests, so uniqueness of responses does not depend on
\dataR{} field for stores.)
\small
\begin{multline*}
\textit{uniqRespLabels} := \forall (r_1, r_2 \in \Response),\\
r_1.\labelR = r_2.\labelR @-> r_1.\timeR = r_2.\timeR \wedge\\
(\reqFn(r_1.\labelR) = \Ld @-> r_1.\dataR = r_2.\dataR)
\end{multline*}
\end{defn}

\begin{defn} (No response can share the same time as another store response.)
\small
\begin{multline*}
\textit{uniqStTimes} := 
\forall (r_1, r_2 \in \Response),
r_1.\timeR = r_2.\timeR @-> \\
(\reqFn (r_1.\labelR)).\addrQ = (\reqFn (r_2.\labelR)).\addrQ @->\\
(\reqFn (r_1.\labelR)).\desc = \St @->
r_1.\labelR = r_2.\labelR
\end{multline*}
\end{defn}

In addition, the global ordering of responses to the same processor should not
violate the local ordering of the corresponding requests.

\begin{defn}
\small
\begin{multline*}
\textit{localOrdering} :=
\forall (r_1, r_2 \in \Response), (r_1.\labelR).\fst = (r_2.\labelR).\fst @->\\
(r_1.\labelR).\snd < (r2.\labelR).\snd @-> r_1.\timeR \le r_2.\timeR
\end{multline*}
\end{defn}

This brings us to the main condition for store atomicity which states that the
value returned for a load response corresponds to the \emph{last earlier} store
request that has been processed in the system for that address This is
indicated by the proposition \textit{lastEarlierValue}$(r)$ for response $r$.
The \emph{last} and \emph{earlier} are defined according to the field \timeR{}
returned in the responses. In case no store has happened earlier for a
particular address when a load is processed, then the load response returns the
initial value for the address. This is indicated by the proposition
\textit{initialValue}$(r)$ for response $r$.
\begin{defn}
\small
\begin{multline*}
\textit{initialValue} := \lambda (r \in \Response) \Rightarrow
(\reqFn (r.\labelR)).\desc = \Ld @->\\ r.\dataR = \initData (r.\addrQ) \wedge 
\forall (r' \in \Response), 0 \le r'.\timeR < r.\timeR @->\\
\neg ((\reqFn (r'.\labelR)).\addrQ = (\reqFn (r.\labelR)).\addrQ \wedge (\reqFn (r'.\labelR)).\desc = \St)
\end{multline*}
\end{defn}

\begin{defn}
\small
\begin{multline*}
\textit{initialValue} := \lambda (r \in \Response) \Rightarrow
(\reqFn (r.\labelR)).\desc = \Ld @->
\exists (r_m \in \Response),\\ r.\dataR = (\reqFn (r_m.\labelR)).\dataQ \wedge 
(\reqFn (r_m.\labelR)).\desc = \St \\ \wedge (\reqFn (r_m.\labelR)).\addrQ = (\reqFn (r.\labelR)).\addrQ\\ \wedge
\forall (r' \in \Response), r_m.\timeR \le r'.\timeR < r.\timeR @->\\
\neg ((\reqFn (r'.\labelR)).\addrQ = (\reqFn (r.\labelR)).\addrQ \wedge (\reqFn (r'.\labelR)).\desc = \St)
\end{multline*}
\end{defn}

Using the above definitions, we can define the store-atomicity theorem as follows:
\begin{thm}
\small
\begin{multline*}
storeAtomicity := 
\textit{uniqRespLabels} \wedge
\textit{uniqStTimes} \wedge \textit{localOrdering}\\ \wedge 
(\forall (r \in \Response), \textit{initialValue}(r) \vee \textit{lastEarlierValue}(r))
\end{multline*}
\end{thm}
