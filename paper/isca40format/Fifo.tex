\section{Virtual channel requirements and ordering}
\label{sec:orderingBlocking}

\newcommand{\fourAngle}[6]{\text{$#1\langle#2\rightarrow#3,#4,#5\rightarrow#6\rangle$}}
\newcommand{\threeAngle}[5]{\text{$#1\langle#2\rightarrow#3,#4,#5\rangle$}}

\newcommand{\Req}[5]{\fourAngle{Req}{#1}{#2}{#3}{#4}{#5}}
\newcommand{\Resp}[5]{\fourAngle{Resp}{#1}{#2}{#3}{#4}{#5}}
\newcommand{\RespOld}[4]{\threeAngle{Resp}{#1}{#2}{#3}{#4}}

%We already gave the ordering requirements between messages (Figure
%\ref{ordering}), and which messages should not be blocked by other
%messages (Figure \ref{blocking}). These are the minimum constraints to
%ensure correctness and deadlock-freedom of the hierarchical coherence
%protocols. Any practical implementation will restrict the ordering between
%messages further, but they must ensure that the messages that should not be
%blocked according to Figure \ref{blocking} are not blocked. In this
%section, we will discuss several such implementations. Note that the
%constraints in Figures \ref{ordering} are on messages for the same
%address; messages for different addresses can be processed in any order. This
%permits implementation of non-blocking caches using MSHRs.

In this section, we show how the constraints of figures \ref{blocking} and
\ref{ordering} can be implemented realistically.
%We already gave the ordering requirements between messages (Figure
%\ref{ordering}), and which messages should not be blocked by other
%messages (Figure \ref{blocking}). These are the minimum constraints to
%ensure correctness and deadlock-freedom of the hierarchical coherence
%protocols. Any practical implementation will restrict the ordering between
%messages further, but they must ensure that the messages that should not be
%blocked according to Figure \ref{blocking} are not blocked. In this
%section, we will discuss several such implementations. Note that the
%constraints in Figures \ref{ordering} are on messages for the same
%address; messages for different addresses can be processed in any order. This
%permits implementation of non-blocking caches using MSHRs.

\subsection{Virtual channels to prevent inadmissible blocking}

Since responses should not be blocked by requests (Constraint \ref{blockresp}),
the requests and responses should be in separate virtual channels. Since a
request from a child of a cache node should not block a request from the parent
of that node (Constraint \ref{blockreq}), the requests from the children to a
node and requests from the parent to the node should use separate virtual
channels.

Between any two levels in the hierarchy, it is enough to have just one virtual
channel for requests going from the higher to the lower level and one for
requests going from the lower to the higher level. %For example, in the
%hierarchy shown in Figure \ref{fig:vc}, only 6 virtual channels are required.
In general, if the memory system has $N$ levels, only $2N$ virtual channels are
required for requests, irrespective of the number of nodes in each level, the
number of children in each node, \etc. The formal proof for this requirement is
beyond the scope of this paper, but here's the outline. As long as a request,
which is still not removed from a virtual channel, does not produce more
requests that use the same virtual channel, the system will not deadlock. In
the memory hierarchy, a request from level $x$ to level $y$ does not produce
another request from level $x$ to $y$. So one virtual channel between every two
levels, in each direction, is sufficient to avoid network-induced deadlocks.

Since a response does not produce more messages and can always be dequeued from
the network, just having one (separate) virtual channel, $RespChannel$, for
responses in the entire system is sufficient to avoid deadlocks. This is
irrespective of the number of levels in the memory hierarchy, the number of
caches in each level, \etc.

\subsection{Guaranteeing ordering requirements using point-to-point FIFO
ordering in the network}

If the network provides FIFO ordering for messages sent between the same nodes
using the same virtual channel, and if all responses between two nodes use the
same virtual channel for each direction always, Constraint \ref{orderresp} is
guaranteed. As noted above, since one virtual channel is sufficient to carry
responses for the entire system, a point-to-point FIFO ordering for that
virtual channel is sufficient.
 
However, in order to guarantee Constraint \ref{orderreq}, FIFO ordering must be
guaranteed even for messages sent on different virtual channels between the
same two nodes (since requests and responses should go in at least two separate
virtual channels). Guaranteeing point-to-point FIFO ordering for messages on
different virtual channels is expensive.

\subsection{Guaranteeing ordering requirements without a point-to-point FIFO
ordering in the network}
\label{sec:nofifoorder}

Instead of relying on the network to provide a point-to-point FIFO ordering for
messages on different virtual channels, Constraint \ref{orderreq} can be
guaranteed by the protocol.

A downgrade request for an address from a parent to a child contains the
directory state of the parent for the address just before the request was sent,
in addition to value of the state to downgrade to. Similarly an upgrade request
for an address from child to its parent should contain the state of the child
for the address just before the request was sent, in addition to the value of
the state to upgrade to. Request messages have a $fromState$ tagged to it, and
thus have a new format \Req{src}{dst}{addr}{fromState}{toState}.

When a child $c$ receives a request \Req{P}{c}{a}{x}{y} from the parent, if
$state[c][a] < x$, then handling of the request is postponed by the child till
it receives a response \RespOld{P}{c}{a}{z} from the parent, where $z \ge x$.
The formal proof is beyond the scope of the paper; the intuition here is that
\RespOld{P}{c}{a}{z} must have been sent by the parent before sending
\Req{P}{c}{a}{x}{y}. Similarly, when a parent receives request
\Req{c}{P}{a}{x}{y} from child $c$, if $dir[c][a] > x$, then handling of the
request is postponed by the parent till it receives a response
\RespOld{c}{P}{a}{z} from $c$, where $z \le x$.

Response messages sent from a child to its parent can also avoid relying on the
point-to-point FIFO ordering in the network using a similar approach. Response
messages from the child to its parent will also have a $fromState$ field with
the new format \Req{src}{P}{addr}{fromState}{toState}. A response
\Resp{c}{P}{a}{x}{y} is not handled by the parent if $dir[c][a] > x$ until it
receives another response \Resp{c}{P}{a}{w}{z} where $z \le x$.

One issue with this for responses is that since only one virtual channel
$RespChannel$ is used for responses throughout the system, a response sent
later for an address from a child to its parent can block a response for the
same address from the same child to its parent sent earlier. This violates
Constraint \ref{orderresp}. If separate virtual channels are used for each type
of response sent by children, classified by $toState$ \ie the value of the
coherence state that a child sending the response has downgraded to, Constraint
\ref{orderresp} will be satisfied. Thus we have one virtual channel,
$RespChannel_{toState}$, for each $toState$. The responses sent by a parent to
its children can use any of the $RespChannel_{toState}$ virtual channels, since
these responses have no ordering requirements, and can share the virtual
channel used for responses sent from children to their parents. Thus, for an
MSI protocol, just two virtual channels are required ($RespChannel_I$ and
$RespChannel_S$).

The most common scenario is when a child sends responses \emph{voluntarily}
only for evictions because of replacement; in all other cases, it only sends
responses on receiving requests from the parent. Since the parent does not send
a second request for the same addres before receiving the response for the
first request, every response from the child, except a response to downgrade to
state $I$ because of eviction, will be received by the parent in FIFO order.
Thus just 2 virtual channels, one for responses to downgrade to $I$ and one for
responses to downgrade to any other state is sufficient, even for protocols
other than MSI.

The implementation described above avoids the need for sending \emph{ack}
messages to guarantee the required ordering, thus reducing the number of
messages as well as unblocking a cache line (for handling further requests)
ithout waiting for acks.
