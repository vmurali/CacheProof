\section{Invariants}
\label{sec:properties}

We first give a list of invariants or global properties that are needed to
ensure that the distributed, hierarchical, MSI protocol in Figure
\ref{realistic} is correct.
The need for these invariants is intuitive. If, for instance, a thread wants to
send a message in the output channel of the node and is not able to send one
forever, then the thread can not proceed further. If a thread is waiting for a
response (for a request previously sent), and it never gets the response, the
thread can never proceed further. A thread can also not proceed if it's waiting
for being allocated in a free line but never gets one because all the lines are
locked up. These scenarios create a deadlock.

We will illustrate the need for Invariants \ref{pcSame}, \ref{cpSame} and
\ref{conservative} using the same example that we used in Section
\ref{sec:network}.

Invariant \ref{pcSame} and \ref{cpSame} are important to make sure that the data
transfers happen correctly. Let $p.dir[c_1][a] = S$, $p.dir[c_2][a] = I$,
$c_1.state[a] = S$, and $c_2.state[a] = I$. $c_2$ gets a store request, and
sends an upgrade-to-$M$ to $p$. $p$ receives the request, but assumes that
$c_1$ already has data for $a$ since $p.dir[c_1][a] = S$. Invariant \ref{pcSame}
is violated. So, it does not transfer the data to $c_1$, resulting in $c_1$
waiting for data, and hence deadlock. A dual condition can be constructed
similarly, in which $c_1$ downgrades its state for address $a$ from $S$ to $I$,
and the parent assumes that $c_1$ is in state $M$, and keeps waiting for data.

Invariant \ref{conservative} is important because a parent node consults its
directory to decide the children it needs to send a downgrade request to.  Let
$p.dir[c_1][a] = S$, $c_1.state[a] = S$, $p.dir[c_2][a] = I$ but
$c_2.state[a] = S$. If $c_1$ gets a store request from the processor and sends
an upgrade-to-$M$ request to $p$, $p$ will assume that $c_2$'s state for address $a$
is also $I$ and hence send an upgrade-to-$M$ response to $c_1$. But since the real
state of  $c_2$ for address $a$ is $S$, it will break Single-writer Invariant
\ref{singleWriter}.

If Invariants \ref{canSend}, to \ref{cpSame} hold, then the procedures given
in Figure \ref{realistic} can not deadlock because it will always be able to a)
send a request, b) send back a response, c) get back a response for a request
it sent, d) receive data when required.

Procedure \uReq{} in Figure \ref{msi-template} relies on the Invariant
\ref{conservative} being true in order to maintain the Single-writer Invariant
\ref{singleWriter}.

In procedures \uResp{}, \dResp{} and \dRespL{} (Figure \ref{realistic}), the
data transfers rely on Invariants \ref{pcSame} and \ref{cpSame} being true in
order to maintain the Read-from-last-writer Invariant \ref{lastRead}.

Thus, if we can somehow prove that Invariants \ref{canSend} to
\ref{conservative} holds for the distributed protocol given in Figures
\ref{msi-template}, \ref{realistic} and \ref{scheduler}, then the protocol will
implement cache coherence correctly, without deadlocks. The formal proof of why
the distributed protocol obeys the above invariants is beyond the scope of the
paper. However, we will list some of the local properties that were extracted
from the distributed protocol that was useful in proving Invariants
\ref{canSend} to \ref{conservative}. We will also give intuition about how
violating a particular local property can lead to deadlocks or violation of
Invariant \ref{conservative}. It can easily be seen that the distributed
protocol indeed satisfies these local properties. MUST REWRITE THIS WITH NETWORKS
