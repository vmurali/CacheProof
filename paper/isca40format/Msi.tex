\section{MSI protocol}
\label{sec:msi}

\newcommand{\printall}[5]{\text{$#1 \langle #2 \rightarrow #3, #4, #5 \rangle$}}
\newcommand{\Req}[4]{\printall{Req}{#1}{#2}{#3}{#4}}
\newcommand{\Resp}[4]{\printall{Resp}{#1}{#2}{#3}{#4}}
\newcommand{\Data}[5]{\printall{Data}{#1}{#2}{#3}{#4}{#5}}

\newcommand{\lett}{\textbf{let}}
\newcommand{\send}{\textbf{send}}
\newcommand{\receive}{\textbf{receive}}
\newcommand{\pop}{\textbf{pop}}
\newcommand{\remove}{\textbf{remove}}
\newcommand{\assert}{\textbf{assert}}
\newcommand{\call}{\textbf{call}}
\newcommand{\dReq}{\textsc{handleDownReq}}
\newcommand{\uReq}{\textsc{handleUpReq}}
\newcommand{\dReqL}{\textsc{sendDownReq}}
\newcommand{\uReqL}{\textsc{sendUpReq}}
\newcommand{\dResp}{\textsc{sendDownResp}}
\newcommand{\uResp}{\textsc{sendUpResp}}

Let us walk through our framework using the example of a hierarchical MSI
protocol.

\begin{figure}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$c.state[a]$ & coherence state (from set $\{M, S, I\}$) of cache $c$ for address $a$\\
$c.data[a]$ & data in cache $c$ for address $a$\\
%$c.dir[n][a]$ & $c$'s notion of the coherence state of $n$ for address $a$\\
\hline
\end{tabularx}
\caption{Notations}
\label{table:lineinfo}
\end{figure}

\begin{wrapfigure}{r}{.4\linewidth}
\centering
\begin{tabular}{|c|ccc|}
\hline
& $M$ & $S$ & $I$\\
\hline
$M$ & $=$ & $>$ & $>$\\
$S$ & $<$ & $=$ & $>$\\
$I$ & $<$ & $<$ & $=$\\
\hline
\end{tabular}
\caption{$<$ and other relations for MSI states}
\label{msi<}
\end{wrapfigure}

Each cache stores the information given in Figure \ref{table:lineinfo}. The
coherence state for an address denotes the (usual) permission that a cache has
for the address: $M = \{R, W\}, S = \{R\}, I = \{\}$. We can define a $<$
relation for coherence state values based on the permissions the states
represent. This is shown in Figure \ref{msi<}. State $I$ is akin to address $a$
not present in the cache.

\begin{wrapfigure}{r}{.46\linewidth}
\begin{subfigure}{.27\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$S$ & $\rightarrow$ & $S$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\caption{$toCompatible$}
\label{toCompat}
\end{subfigure}
~~~~~~~~~~~~~~
\begin{subfigure}{.21\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $\checkmark$\\
$S$ & $\times$\\
$I$ & $\times$\\
\hline
\end{tabular}
\caption{$isModified$}
\label{isModified}
\end{subfigure}
\caption{$toCompatible$ and $isModified$ mappings}
\label{fig:msimap}
\end{wrapfigure}

If a cache $c$ receives a request for an address $a$ from the processor, it can
service the request straightaway if it has enough permissions for address $a$.
Otherwise, it has to \emph{upgrade} to a state $x$, which has enough
permissions. The cache can not upgrade its state arbitrarily, it has to ensure
that such a state change does not violate the single-writer property (Invariant
\label{singleWriter}), by \emph{downgrading}, \ie lowering the states of other
caches appropriately. We define a $toCompatible(x)$ mapping (Figure
~\ref{toCompat}), which specifies the highest state a cache can be, if another
cache is in state $x$ for the same address. We will also define a
$isModified(x)$ mapping to specify if an address in state $x$ in a cache can
have data different from what's present in the memory.

\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReq}{$c , p, a, x$}
  \If {$a$ is not present in $p$}
    \State Choose address $a'$ for eviction;
    \ForAll {$c' \in p.children$}
      \State \call{} \dReq($p , c', a', I$);
    \EndFor
    \State \call{} \dResp($p , p.parent, a', I$);
    \State Replace $a'$ with $a$ (initializing $p.state[a]$ to $I$);
  \EndIf
  \ForAll {$c' \in p.children, s.t., c' \neq c$}
    \State \dReq($p , c', a, toCompatible(x)$);
  \EndFor
  \State \uReqL($p , p.parent, a, x$);
  \State \uResp($p , c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Handling upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , c, a, x$}
  \ForAll {$c' \in c.children$}
    \State \dReqL($c , c', a, x$);
  \EndFor
  \State \dResp($c , p, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Handling downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dReq}
\end{subfigure}

\caption{MSI protocol}
\label{msi}
\end{figure}

\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$c , p, a, x$}
  \State \call{} \uReq($c, p, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , c, a, x$}
  \State \call{} \dReq($p, c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , c, a, x$}
  \If {$c.state[a] < x$}
    \If {$c.state[a] = I$}
      \State $c.data[a] \gets p.data[a]$;
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $c$ for address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$c , p, a, x$}
  \If {$c.state[a] > x$}
    \If {$isModified(c.state[a])$}
      \State $p.data[a] \gets c.data[a]$;
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ response from $c$ to $p$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , core, a, x$}
  \State $c.data[a] \gets p.data[a]$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $core$ for address $a$}
\label{uResp}
\end{subfigure}


\caption{Atomic MSI}
\label{atomic}
\end{figure}


\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$c , p, a, x$}
  \State \send{} \Req{c}{p}{a}{x};
  \State \pop{} \Resp{p}{c}{a}{z};
  \If {$c.state[a] = I$}
    \State \pop{} \Data{p}{c}{a}{d};
    \State $c.data[a] \gets d$;
  \EndIf
  \State $c.state[a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReqLocal}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReqL}{$p , c, a, x$}
  \State \send{} \Req{p}{c}{a}{x};
  \State \pop{} \Resp{c}{p}{a}{z};
  \If {$isModified(p.dir[c][a])$}
    \State \pop{} \Data{c}{p}{a}{d};
    \State $p.data[a] \gets d$;
  \EndIf
  \State $p.dir[c][a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , c, a, x$}
  \If {$p.dir[c][a] < x$}
    \If {$p.dir[c][a] = I$}
      \State \send{} \Data{p}{c}{a}{p.data[a]};
    \EndIf
    \State $p.dir[c][a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $c$ for address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$c , p, a, x$}
  \If {$c.state[a] > x$}
    \If {$isModified(c.state[a])$}
      \State \send{} \Data{c}{p}{a}{c.data[a]};
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ response from $c$ to $p$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , core, a, x$}
  \State \send{} \Data{p}{c}{a}{p.data[a]};
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $core$ for address $a$}
\label{uResp}
\end{subfigure}

\caption{Realistic MSI protocol}
\label{realistic}
\end{figure}

