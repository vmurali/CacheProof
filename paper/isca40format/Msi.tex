\section{MSI protocol}
\label{sec:GlobalMsi}


The caches are logically organized in the form of a tree
(Figure~\ref{hierarchy}) where the leaves represent L1 caches and the root is the last level cache (LLC). Each L1 is connected to exactly one core and the LLC is connected to the memory. The cache hierarchy is
inclusive, \ie if an address is present in a cache $c$, then it must also be present in its parent $c.parent$. Note that by address we mean cache-line address, not a byte address or a word address.

Each cache stores the coherence state and the data for each address that it
contains. 
% Figure \ref{notation} gives the notation used to represent all this information. 
For an L1 cache, the coherence state for an address denotes the
(usual) permission that a core connected to the L1 cache has for the address: $M
= \{R, W\}, S = \{R\}, I = \{\}$. We can define a $<$ relation for coherence
state values based on the permissions the states represent, that is, $I < S < M$. 
For an internal or non-L1 cache, the meaning of the coherence states has to be generalized. For cache $c$, $c.state[a] = I$ means that each cache in the entire sub-tree rooted at $c$ will have coherence state $I$ for address $a$. 
$c.state[a] = S$ means that the children of $c$ can either be in $S$ or $I$ state. Finally, $c.state[a] = M$ means that 
at most one of c's children can be in state $M$. If the state bits are manipulated properly then the following invariants will hold.

\begin{theorem}
\textbf{Single-writer Invariant}: When an L1 cache has permission to modify data for
an address, no other L1 cache has read or write permission for that address. 
\label{singleWriter}
\end{theorem}

\begin{theorem}
\textbf{Read-from-last-writer Invariant}: When a core reads data for an address
in L1, it gets the value that was either last stored in that address by some
core, or if no core has stored any value in that address previously, the
initial value from the memory.
\label{lastRead}
\end{theorem}

\begin{wrapfigure}{r}{.6\linewidth}
\begin{subfigure}{.55\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$S$ & $\rightarrow$ & $S$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\caption{$maxCompatible$}
\label{toCompat}
\end{subfigure}
\begin{subfigure}{.24\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $True$\\
$S$ & $False$\\
$I$ & $False$\\
\hline
\end{tabular}
\caption{$isModified$}
\label{isModified}
\end{subfigure}
\caption{MSI auxiliary functions ($I < S < M$)}
\label{funcs}
\end{wrapfigure}
In Figure \ref{funcs} we define some auxiliary functions $maxCompatible(x)$ and $isModified(x)$ which are useful in describing protocols to maintain the invariant.

The MSI protocol maintains the invariant essentially by a cache requesting its parent a state upgrade, \ie $I$ to $S$, $I$ to $M$ or $S$ to $M$. The parent grants this request by downgrading its other children as necessary or requesting an upgrade of its own state from its parent. The data is also transferred from one cache to another as appropriate. In our protocol descriptions each cache in the hierarchy is treated as a C++/Java like object with methods to process upgrade and downgrade requests. A special method called \textsc{coreReq} is provided for L1's so that the core can initiate a load or a store request as shown in Figure \ref{coreHandle}. The L1 cache checks if the request
can already be serviced, if not, it invokes its upgrade request handler \uReq{},
which eventually upgrades the state of the requested address. Finally, in the case 
of a load request, the data is sent back to the core, and in the case of a store, the
cache line is updated. Note that the core supplies words or long-words while the
cache line sizes are typically 64 bytes; only the appropriate word in the cache
line is updated in case of a store.


\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}
\small
\begin{algorithmic}
\Proc {\textsc{coreReq}}{$core, a, op, data$}
  \If {$op = Ld$}
    \State \textbf{if} ($this.state[a] < S$)
    \State \;\;\;\; \call{} $this.$\uReq($core, a, S$);
    \State \send{} $this.data[a]$ (to $core$);
  \ElsIf {$op = St$}
    \State \textbf{if} ($this.state[a] < M$)
    \State \;\;\;\; \call{} $this.$\uReq($core, a, M$);
    \State $update(this.data[a], data)$;
  \EndIf
\EndProc
\end{algorithmic}
\caption{L1 cache $this$ handling a load or a store request sent by $core$ by
calling the request handler}
\label{coreHandle}
\end{figure}



\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}
\small

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReq}{$c , a, x$}
    \If {$a$ is not present in $this$}
      \If {$this$ has no space for $a$}
        \State Choose address $a'$ for eviction;
        \State \textbf{forall} ($c' \in this.children$)
        \State \;\;\;\; \textbf{if} ($c'.state[a] > I$)
        \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a', I$);
        \State \textbf{if} ($this.state[a'] > I$)
        \State \;\;\;\; \call{} $this.$\dResp{}($this.parent, a', I$);
      \EndIf
      \State Allocate a line for $a$;
    \EndIf
    \State // $a$ is already present in $this$
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} ($c'.state[a] > maxCompatible(x)$)
    \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a', maxCompatible(x)$);
    \State \call{} $this.$\uReqL{}($this.parent, a, x$);
  \State \textbf{if} ($c \neq core$)
  \State \;\;\;\; \call{} $this$.\uResp{}($c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's upgrade request handler -- request from one of $this$' children, $c$, to upgrade $c$'s state to $x$ for address $a$ }
\label{atomicUReq1}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , a, x$}
  \If {$this.state[a] > x$}
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} (c'.state[a] > x)
    \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a, x$);
    \State \call{} $this.$\dResp($p, a, x$);
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's downgrade request handler -- request from $this$'
parent, $p$, to upgrade $p$'s state to $x$ for address $a$ }
\label{atomicDReq1}
\end{subfigure}

\caption{MSI protocol}
\label{msi-template}
\end{figure}

We will first describe the upgrade and downgrade methods as sequential procedures which can access and modify the state of any cache in the system (see
Figure \ref{msi-template}).  
When the upgrade request handler \uReq{} for a cache $this$ is invoked by a
cache $c$ to go to a particular state $x$, $this$ first makes sure that it has space to process it. This means that if $a$ is not present in $this$, it allocates a new line for that address, sometimes by evicting another line. This requires downgrading the status of the evicted address in all its children. Next, $this$ ensures that its
other children are ``compatible'' with $c$ being in state $x$ for the requested
address. For example, for $c$ to go to state $M$, all the children of $this$, except for $c$ must be in state $I$. If some children are not in state $I$ then the parent (\ie $this$) must downgrade them to go into state $I$. In the protocol, this is accomplished by the parent asking the child to downgrade their state to $maxCompatible(x)$. If the child's state is such that $isModified(state)$ is true, then it will contain the latest version of the data for address $a$, and hence this data has to be written back into the parent's cache.
If $this$' state is less than the requested state it invokes
its parent's handler for an upgrade request to $x$. Finally, when state of $this$ is $x$ and all its children are compatible with $x$, $this$ can upgrade
$c$'s state, and send the data if $c$'s state was $I$ previously. This is shown
in Figure \ref{atomicUReq1}.

Any cache except the LLC can get a downgrade request from its parent. Figure \ref{atomicDReq1} defines this downgrade method \dReq{} where the cache
ensures that each of its children's state is not higher than $x$, by invoking
their respective downgrade methods. When all the children have downgraded, the
cache downgrades its own state to $x$, and sends data back to the parent, if it
has been modified.




\begin{figure}
\small

\begin{algorithmic}
\State // Upgrading $this$ by invoking parent's upgrade handler
\Proc {\uReqL}{$p, a, x$}
  \State \textbf{if} ($this$ is LLC \&\& $this.state[a] = I$) \bopen
  \State \;\;\;\; $this.data[a] \gets memory[a]$;
  \State \;\;\;\; $this.state[a] \gets M$;
  \State \bclose \textbf{else}
  \State \;\;\;\; \call{} $p.$\uReq($this, a, x$);  
\EndProc

\State // Invoking the child's downgrade handler
\Proc {\dReqL}{$c , a, x$}
  \State \call{} $c.$\dReq($this, a, x$);
\EndProc

\State // $this$ finally upgrades the state (and if necessary, data) of its child
\Proc {\uResp}{$c, a, x$}
  \If {$c.state[a] = I$}
    \State $c.data[a] \gets this.data[a]$;
  \EndIf
  \State $c.state[a] \gets x$;
\EndProc

\State // $this$ downgrades its own state and updates the parent's data
\Proc {\dResp}{$p, a, x$}
  \If {$isModified(c.state[a])$}
    \State $p.data[a] \gets this.data[a]$;
    \State // $p.data$ refers to $memory$ if $this$ is LLC
  \EndIf
  \State $this.state[a] \gets x$;
\EndProc

\State // In case of LLC, $this$ reads data from memory
\Proc {\sendMem{}}{$a$}
\EndProc
\end{algorithmic}

\caption{Auxiliary methods used in the MSI protocol of Figure \ref{msi-template}. In all the methods $p$ is the parent of $this$, $c$ is a child of $this$, and the methods work on address $a$ to change its state to $x$}
\label{atomic}
\end{figure}

The methods to handle upgrade and downgrade requests in turn use 5 auxiliary methods defined in Figure \ref{atomic}. These methods are very simple and could have been inlined. However, they do recursively call $this$' parent's \uReq{} or $this$' children's \uReq{}. We have chosen not to inline them because these functions encapsulate all accesses to other caches when we systematically transform this protocol for distributed implementation. Note however that \uReq{} and \dReq{} read the states of its children. We will make those reads local by keeping a directory as discussed in the next section.

All lines in the LLC are always in $M$ state.
