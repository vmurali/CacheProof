\section{Caches as a distributed system of multi-threaded execution engines}
\label{sec:threads}

The memory hierarchy in a processor can be specified as a collection of nodes
(Figure \ref{distNodes}). Each node has local state associated with it. The
state may contain the cache and the directory among other book-keeping
information. A node also has multiple input and multiple output channels
through which it can send and receive messages. Most of the channels are
connected to a network, which delivers messages between nodes
%; the message delivery order is left unspecified
. Some of the channels may not be connected to the network; they represent
inputs and outputs to the memory system, \viz the requests from and responses to
cores.

The behavior of each node can be best described as a system of suspendable local
threads, with a scheduler local to that node. A thread can be in one of the two
states: \emph{executing} or \emph{suspended}. At a given time, either one
thread or the scheduler will be executing. When the scheduler is executing,
it does one of the following: a) picks one of suspended threads
which has become ready to execute due to changed conditions or b) creates a new
thread to handle an incoming message. An executing thread can read the local
state of the node, send messages to output channels, receive messages from
input channels, \etc% or spawn more threads . The input and output channels are
blocking, so if a thread tries to send to a full output channel or receive from
an empty input channel, the thread would not be able to proceed. The thread can
also fail to proceed due to some condition in the local state of the node. In
all these cases, the thread gets suspended, giving back control to the
scheduler. It remains suspended till the required conditions are met (for
instance, the output channel becomes free, the input channel receives a
pertinent message, or other local state changes), Once the required conditions
for a suspended thread are met the scheduler may pick it for execution. The
execution is resumed from the exact point where it was suspended. Once the
thread finishes its execution, all the book-keeping resources associated with
that thread is freed up and reclaimed.

Incoming messages remain in the channel until they are explicitly removed by
the thread dealing with that message. If the scheduler sees an incoming message
that requires a new thread to be created for handling, and if the required
book-keeping resources are available, then a thread is created.
%Different threads require different amounts of book-keeping resources.
If the
required book-keeping resources are not available, the scheduler might pick
another suspended thread which is ready to execute, or if that's not possible,
spin-waits.  The threads and incoming messages have a memory address associated
with them. For an incoming message that does not require a new thread to be
created, its address is used by the scheduler to decide if a suspended thread
is ready to execute. Similarly, the address associated with a thread that has
just finished executing is used to determine if the local state of the node
associated with that address has changed so that a suspended thread associated
with that address can resume execution.  

Note that the thread analogy we described above has nothing to do with software
threads. We are describing the behavior of a cache controller using the familiar
notion of suspendable threads. The threads essentially correspond to the various
requests being handled by a cache controller's Miss Status Handler Register
(MSHR).

\begin{figure}
\begin{tabularx}{\linewidth}{|l|X|}
\hline
\send{} $m$ & Send a message $m$ to the node's output channel. This action
blocks till the channel has space to send.\\
\receive{} $m$ & Receive and remove a message $m$ from the node's input channel.
This action blocks till a message is received.\\
$x \gets value$ & Local state $x$ of the node gets updates to $value$.\\
%\call{} $f(args)$ & Execute \textbf{procedure} $f$ with $args$ arguments.\\
%\start{} $f(args)$ & Start a new thread that executes \textbf{procedure} $f$
%with $args$ arguments. This action is performed only by the scheduler.\\
\resume{} $t$ & Resume thread $t$ from where it stopped execution. This action
is performed only by the scheduler\\
\hline
\end{tabularx}
\caption{Actions used for describing a node's behavior}
\label{actions}
\end{figure}

When a new message arrives in an input channel that requires creation of a
thread, the scheduler first removes the message from the channel and then
creates a thread that starts executing the \procedure{} specific to the type of
the incoming message. Figure \ref{actions} show the notations we use to
describe the actions performed by an executing thread. Procedures can call
other procedures but they can not be recursive. We usually denote the execution
of actions \receive{} and \send{} using their verb forms, for instance,
,``receiving'' or ``sending''. We also denote the thread created by the
scheduler to handle an incoming message as the thread ``handling'' that
message.
