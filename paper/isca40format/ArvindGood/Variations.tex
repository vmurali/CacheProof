\section{Implementing variations of basic MSI protocol}
\label{sec:variations}

%\renewcommand{\fourAngle}[6]{\text{$#1\langle#2\rightarrow#3,#4,#5\rightarrow#6\rangle$}}

\newcommand{\FwdReq}[3]{\text{$FwdReq\langle#1,#2\rightarrow#3\rangle$}}
\newcommand{\FwdAck}{\text{$FwdAck$}}

%\renewcommand{\Req}[5]{\fourAngle{Req}{#1}{#2}{#3}{#4}{#5}}
%\renewcommand{\Resp}[5]{\fourAngle{Resp}{#1}{#2}{#3}{#4}{#5}}

In this section we describe variations of the basic MSI hierarchical
message-passing directory-based protocol and show how our framework can be used
to design and argue their correctness easily.
%The
%arguments are based on the formally proven Invariants of Figure
%\ref{invariants}. The ordering requirements in Figure \ref{ordering} are
%handled at the protocol level by sending the state at which the sender was in
%just before sending the message as discussed in Section \ref{sec:nofifoorder}

\subsection{MESI optimization}
We first describe the MESI variation of the message-passing MSI protocol for a
two-level hierarchy containing multiple L1 caches and directory shared by all
the L1 caches. On receiving a request from a cache $c$ to upgrade $c$'s state
for address $a$ to $S$, the directory sends permission to upgrade the state of
$c$ for address $a$ to ``exclusive'' ($E$), if the directory state of every
other cache for that line is $I$ (and because of our Invariant
\ref{conservative}, the coherence state of every other cache for that line is
also $I$). Once cache $c$ has upgraded to $E$, it can automatically upgrade to
$M$ on receiving a store request from the processor, without sending any
notification to the directory.  However, if some other cache $c'$ sends a
request to the directory for address $a$ to upgrade to state $S$, the directory
has to ensure that the cache $c$ has downgraded its state from $E$ to $S$. If
$c$ remains at $E$ without having upgraded to $M$, then it doesn't have to send
the data back to the memory, while downgrading to $S$.

From the directory's perspective, states $M$ and $E$ are equivalent -- the only
distinction is that the cache would not send back the data while downgrading the
state for an address from $E$. Thus MESI is simply an optimization over the MSI
protocol in which the cache maintains an extra dirty bit for each address, and
sends back the cache line data to the directory during a downgrade only if the
dirty bit is set (the dirty bit can not be set for an address if the
corresponding state is $S$). If the dirty bit is not set during a downgrade, the
cache sends back a message denoting ``data unmodified'' in the place of actual
data. In the hierarchical setting too, MESI is simply an optimization over MSI
in which a child sends data back to its parent during a downgrade only if the
dirty bit is set.

\subsection{Cache-intervention based protocols}
In the protocols discussed so far, caches can directly communicate only with
their immediate children or with its immediate parent. In cache-intervention
based protocols, communication and data transfer can also take place between
nodes other than the immediate children or the immediate parent. Our framework
can be easily extended to include cache-intervention based protocols where
sibling caches, \ie caches that share the same immediate parent, can communicate
with each other. We show 2 protocols with sibling cache-intervention: a) the MSI
protocol with intervention by a cache in the $M$ state and b) the MOSI/MOESI
protocol. Note that in both the protocols, the MESI optimization can be
implemented whenever a child has to transfer data to its parent -- the MOSI
protocol with MESI optimization is popularly called the MOESI protocol.

We first describe the two protocols using a two-level hierarchy containing
multiple L1 caches and a directory shared by all the L1 caches, and later
describe the extension to a hierarchical system.

\subsubsection{Intervention by a cache in the $M$ state:}
\label{sec:m-only}

In this protocol, a downgrade request sent from the directory to a cache $c$ for
address $a$ can sometimes be augmented with a forwarding request
\FwdReq{fwdDest}{fromState}{toState}, which directs the cache to send an upgrade
response to $fwdDest$ to upgrade $fwdDest$'s state for address $a$ from
$fromState$ to $toState$, on the directory's behalf. A downgrade response from
cache $c$ can also be augmented with \FwdAck{}, which acknowledges the directory
that the requested forwarding has been fulfilled.  Note that normal downgrade
requests from the directory without a forwarding request and normal responses
from the cache without \FwdAck{} are also sent.

Let us walk through the behavior of the system for handling a request from cache
$c'$ for address $a$ to upgrade to state $x$. Here $x = M$ or $x = S$ and let us
denote $toCompatible(x)$ by $y$. Checking if $dir[c][a] > y$ or if $state[c][a]
> y$ is akin to checking if $dir[c][a] = M$ or $state[c][a] = M$ in this
protocol since $y \le S$; using this (general) notation becomes convenient
later.

When a directory receives a request from cache $c'$ for address $a$ to upgrade
to state $x$, it determines if $\exists c, dir[c][a] > y$. If $\forall c,
dir[c][a] \le y$, then the directory behaves in the same manner as MSI -- the
directory responds to $c'$ authorizing it to upgrade to state $x$ for address
$a$, and sends data from memory if necessary. But if $\exists c, dir[c][a] > y$,
then it sends a request to cache $c$ to downgrade its state for address $a$ to
$toCompatible(x)$ augmented with a forwarding request \FwdReq{c'}{w}{x}, where
$w = dir[c'][a]$. This forwarding request is essentially a response sent by the
directory to cache $c'$ to upgrade the state of $c'$ for address $a$ to $x$, but
it is sent via the cache $c$. The directory waits for a downgrade response along
with a \FwdAck{} from $c$ before processing further requests for $a$. On
receiving the response from $c$, the directory would change $dir[c'][a]$ to $x$.

If cache $c$ receives the downgrade request from the directory along with the
forward request \FwdReq{c'}{w}{x}, and if $state[c][a] > y$ $c$ will send a
response to $c'$ authorizing the upgrade of $state[c'][a]$ to $x$, along with
the data associated with address $a$, if $w = I$. It will also send a downgrade
response to the directory notifying that $c$ has downgraded state $a$ to
$toCompatible(x)$ along with a \FwdAck{}; and it sends the data to the memory if
$x = S$.

When $x > S$, then the data in memory is going to be stale anyway (since
$c'$ will eventually have the most up-to-date version), so $c$ does not have to
transfer the data to memory in this case. However, when $x = S$, then $c$ also
downgrades state of address $a$ to $S$ and hence the data in the memory has to
be kept up-to-date, in order to guarantee Read-from-last-writer Invariant
\ref{readLast} for subsequent cache requests.

However, on receiving the downgrade request from the directory, if cache
$state[c][a] \le y$ for address $a$ (because of eviction due to replacement),
then the cache simply drops the request just like in the MSI protocol discussed
earlier. When $c$ downgraded its state earlier for address $a$, just like in the
MSI protocol, it must have sent the downgrade response and the data. The data is
always transferred in this case (subject to MESI optimization) because
the state $state[c][a]$ right before sending the voluntary downgrade
response must have been $> S$ which means $dataToUpper(state[c][a])$ is True,
and so in the MSI protocol, it would have transferred data. But this
voluntary response would not have a \FwdAck{}.

If the directory receives a downgrade response for address $a$ from cache $c$
along with a \FwdAck{}, the directory knows that $c$ has sent a response to
cache $c'$ authorizing $c'$ to upgrade its state for $a$ to $x$. If $x = S$, the
memory is updated with the received data (subject to MESI optimization). It will
finally remove the outstanding request from $c'$ for address $a$ as the request
has been handled.

On the other hand, if the directory receives a downgrade response for address
$a$ from cache $c$ without a \FwdAck{}, the directory knows that $c$ has not
sent a response to cache $c'$. The memory is updated with the received data
(subject to MESI optimization) for address $a$. This case is handled just like
in the MSI protocol, as if the forwarding never happened. It sends a
response to $c'$ authorizing it to upgrade its state for address $a$ to $x$. It
also sends the (just updated) data from memory, if $dir[c'][a]$ was $I$ at the
time of receiving the upgrade to $x$ request from $c'$.

$c'$ would eventually get the upgrade to $x$ response for address $a$ either
from the directory or the cache $c$ -- it can not distinguish between the two
cases.

Figure \ref{msi-inter} shows the order of messages transferred between the
caches in the scenario when forwarding happens as well the in the scenario when
no forwarding happens, for the $M$-only cache-intervention based protocol.

%:------------------- If the
%:Single-writer Invariant \ref{singleWriter} is maintained (and we prove
%:informally below that it is indeed the case), then $dir[c][a] = M$ and
%:$dir[c'][a] = I$ at the time of reception of the downgrade message from $c$.

It can easily be seen that the protocol given above satisfies all the
constraints \ref{} to \ref{}, except, potentially, Constraint \ref{orderreq}.
Before the upgrade response for address $a$ sent from $c$ to $c'$ has reached
$c'$, $c'$ could have received a downgrade request sent from the directory. This
happens as follows (Figure \ref{msi-fifo-needed}, with the numbers indicating
the order in which the messages are sent, for outgoing edges, and received for
incoming edges). Cache $c$ sends the upgrade response (and data) to cache $c'$,
and its own downgrade response along with the \FwdAck{} to the directory. The
directory receives the downgrade response from $c$. Soon afterwards, the
directory wants to downgrade the state of $a$ in $c'$ to $I$ (let's say, because
some other cache wants to upgrade its state for $a$ to $M$).  The directory
sends a downgrade to $I$ request to $c'$ for address $a$. This downgrade request
to $c'$ from the directory reaches $c'$ before the (forwarded) upgrade response
from $c$, violating Constraint \ref{orderreq}. However, as we saw in Section
\ref{sec:nofifoorder}, Constraint \ref{orderreq} can be satisfied by tagging the
downgrade request from the directory with the state the directory was in for
cache $c'$ and address $a$ right before the request to $c'$ was sent -- FIFO
ordering is not required from the network. $c'$ will not process the downgrade
request till it has received the upgrade response from $c$.

Since the protocol satisfies all the constraints \ref{} to \ref{}, it satisfies
all the invariants in Figure \ref{invariants}. Thus the directory is guaranteed
to have a conservative version of the states of each of the caches for each
address by Invariant \ref{conservative}. When the directory sends a downgrade
request for address $a$ to $c$ tagged with a \FwdReq{c'}{x}, it essentially
sends the upgrade response to cache $c'$ for address $a$ simultaneously. This
seemingly violates the compatibility of states for address $a$. For example, if
$c'$ has requested for an upgrade to state $M$ for address $a$, and $c$ is
already in state $M$ for address $a$, if the directory sends an upgrade response
to cache $c'$ without receiving a downgrade response from state $c$, then
according to Constraint \ref{psendeffect}, according to the directory's notion
of caches' states, both $c$ and $c'$ are in state $M$ for address $a$. But the
upgrade response to $c'$ goes via cache $c$. So the state of address $a$ in $c'$
would not have been upgraded to $M$ till $c$ has downgraded its state to $I$ and
the data transferred to $c'$ would be the most up-to-date data, as modified by
$c$. This ensures both the Single-writer Invariant \ref{singleWriter} and the
Read-from-last-writer Invariant \ref{readLast}.

Thus we have mapped the complex protocol with intervention by a cache in $M$
state to a MSI protocol. We have provided an informal sketch of the
proof using our framework of constraints \ref{} to \ref{} and Invariants (Figure
\ref{invariants}); the formal proof is beyond the scope of this paper.

\subsubsection{MOSI/MOESI protocol:}
In the MOSI protocol, if cache $c$ is in $O$ state for an address $a$, informally
it signifies that $c$ is the ``owner'' of the data and hence has to supply the
data for any request from other caches. The data in a cache in state $O$ for an
address can be more up-to-date than the memory, and other caches can have copies
of this data.  In our framework, we extend the $toCompatible$ and $dataToUpper$
mappings, and the $<$ relation to accommodate the $O$ state as shown in Figure
\ref{fig:o-extend}.

\begin{figure}
\begin{subfigure}{.25\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$O$ & $\rightarrow$ & $S$\\
$S$ & $\rightarrow$ & $O$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\subcaption*{$toCompatible$}
\end{subfigure}
\begin{subfigure}{.25\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $\checkmark$\\
$O$ & $\checkmark$\\
$S$ & $\times$\\
$I$ & $\times$\\
\hline
\end{tabular}
\subcaption*{$dataToUpper$}
\end{subfigure}
\begin{subfigure}{.48\linewidth}
\centering
\begin{tabular}{|c|cccc|}
\hline
& $M$ & $O$ & $S$ & $I$\\
\hline
$M$ & $=$ & $>$ & $>$ & $>$\\
$O$ & $<$ & $=$ & $>$ & $>$\\
$S$ & $<$ & $<$ & $=$ & $>$\\
$I$ & $<$ & $<$ & $<$ & $=$\\
\hline
\end{tabular}
\subcaption*{$<$ (and other) relations}
\end{subfigure}
\caption{MOSI protocol mappings and $<$ relations}
\label{fig:o-extend}
\end{figure}

A cache always requests an upgrade to $M$ or $O$ state. It never requests an
upgrade to an $S$ state, even if the cache wants permissions just to read the
location of the memory. So, in our protocol, the ``owner'' state for an address
keeps getting transferred to the last cache that requests read permissions for
the address. This makes the protocol fit into our framework easily.

The directory's and the cache's behavior on receiving a request is exactly the
same as described in the $M$-only cache-intervention based protocol (Section
\ref{sec:m-only}), if $toCompatible$ and $dataToUpper$ functions and the $<$
relations are substituted appropriately. The argument for its correctness is
also exactly the same.

\subsubsection{Salient features of our cache-intervention based protocols:}
%There are two interesting points worth noting in our protocols:

\noindent \paragraph{Acknowledgement that forwarding has taken place is sent
earlier:} \FwdAck{} is sent from the forwarding cache $c$ rather than the final
cache $c'$ which is the case in commonly used protocols \cite{hammer, gems}.
This unblocks the directory to serve further requests for the same address as
soon as \FwdAck{} is received from $c$, instead of waiting for an
acknowledgement from $c'$.

\noindent \paragraph{Writebacks require no acks:} When a cache $c$ is in the $M$
or $O$ state for address $a$, then the address can be evicted from the cache
anytime (for replacement) without having to wait for the directory to
acknowledge this eviction (which is the case in commonly used protocols
\cite{hammer, gems}. Any downgrade response can be sent anytime without
requesting the directory for authorization. This frees up the cache line to
store a different address, without having to wait for authorization from the
directory.

It is interesting to compare the performance of our approach in which a cache
line in $M$ or $O$ state is written back, and the data evicted, against the
commonly used approaches, in which the cache line stays in the cache till the
directory acknowledges the writeback. The difference in performance arises only
in the following scenario: Cache $c$ has an address $a$ in $M$ state, and
another cache $c'$ sends an upgrade from $I$ to $M$ request for address $a$ to
the directory, and the directory has sent a downgrade request along with
\FwdReq{c'}{I}{M} to $c$. By the time $c$ received the downgrade request, it has
already evicted address $a$.

If cache $c$ has evicted address $a$ and sent the downgrade response to the
directory just before it received the downgrade+forward request from the
directory, then that downgrade response has to first reach the memory (takes
almost one ``leg'') and then has to be transferred from the memory to $c'$
(takes another ``leg''). So it takes almost four legs from the time $c'$ sent
the request to the time $c'$ received the response. This is shown in Figure
\ref{fig:4legs}.
%The times at which messages are sent are marked in the outgoing
%edges and the times at which messages are received are marked in the incoming
%edges.

On the other hand, if the directory receives the downgrade response from $c$
right after sending the downgrade+forward request to $c$, then it takes only
slightly more than 2 legs from the time $c'$ sent the request to the time $c'$
received the response. This scenario is depicted in Figure \ref{fig:2legs}

In the other protocols, in both the scenarios $c'$ would receive the response in
exactly 3 legs, as the response would be forwarded by $c$ in both the scenarios.

\subsubsection{Extending the protocol for multiple levels of hierarchy:}
Extending this protocol to multiple levels of hierarchy follows the same
procedure as extending the MSI protocol to multiple hierarchical levels.
Just like in the multi-level MSI protocol, each node in the hierarchy has a
\emph{directoy} $dir[c][a]$, which maintains a conservative version of the
state of each address $a$ in each of its immediate child $c$, and a
\emph{coherence state} $state[a]$ for each address $a$ which represents the
state with respect to the node's parent. If $state[a] = M \text{ or } O$ and
$\forall c, dir[c][a] \le S$, then the directory has the most up-to-date
version of the data, but if $\exists c, dir[c][a] > S$, then the subtree of $c$
has the most up-to-date data for address $a$. This is  the same interpretation
as for $state[a] = M$ in the multi-level MSI protocol.

Note that in the case of multiple levels of hierarchy, only siblings which share
the same immediate parent can communicate with each other during cache
intervention. Thus, the overall behavior for a node to handle incoming downgrade
requests from its parent, and sending downgrade responses to its parent remains
the same -- the only change is the way a node interacts with its own children.

We believe it's hard to allow any node to communicate with any
other node for cache intervention; it certainly can not be handled within our
framework.
