\section{Implementation overhead}
\label{sec:implementation}
In this section we show how the requirements presented in Section \ref{sec:DistributedMsi} can be implemented in a realistic system.

\subsubsection{Implementation using virtual channels:}

Let's first analyse ways to implement the ordering requirements (Figure
\ref{order}) and the blocking restrictions (Figure \ref{blocking}) in an actual
packet-switched network using virtual channels.

Consider $2N$ channels, where $N + 1$ is the number of levels in the hierarchy
(counting both the L1 caches and the LLC). Let's say each of these channels are
indexed by a pair $ReqChannel\langle x, direction \rangle$, $x$ denotes a level
in the hierarchy and $direction$ can either be $ToC$ or $ToP$.  Virtual
channels $1, ToC$ and $N + 1, ToP$ do not exist, giving a total of $2N$
channels. We will now map the requests sent from a cache to another node to
these channels as follows: a request sent from a cache in level $x$ to its
parent uses channel $ReqChannel\langle x, ToP \rangle$, and a request sent from
a cache in level $x$ to any of its children uses channel $ReqChannel\langle x,
ToC \rangle$.

This virtual channel mapping is sufficient for handling any request message in
the system, the reason being as follows: A request message can potentially
produce more request messages. However, a request message from a cache node in
level $x$ to a cache node in level $y$ will not produce any more request
messages sent from any cache node in level $x$ to any cache node in level $y$. A
downgrade request from the parent only produces more downgrade requests to its
children, recursively, so the above invariant is maintained. Similarly, an
upgrade request $R$ from a child $c$ to a parent $p$ produces more upgrade
requests from the parent to its own parent, recursively, and more downgrade
requests going from cache nodes at a higher level to a cache node at a lower
level. But no request message is sent from the level of child $c$ to the level
of parent $p$ to handle request $R$. This mapping also ensures that Requirement
\ref{cReqNoBlockPReq} is met.

Since responses from a child of a cache node should not be blocked at the cache
node by any incoming requests (Requirement \ref{reqNoBlockResp}), the responses
from a cache node at a lower level (children) to a cache node at a higher level
(parent) should not use any of the request channels. Since a
response is always removed by the system, just one channel, $RespChannel$, is
sufficient for transmitting responses from any child to its parent, in the
whole system.

Since responses from the parent $p$ of a cache node $c$ should not be blocked
at the cache node by a request from $c$'s child $c'$, these responses can not
use the same channel as that used by a request from $c'$ to $c$. However, they
can use the same virtual channel used by the requests from $p$ to $c$,
$ReqChannel\langle x, ToC \rangle$, where $x$ is the level of $p$. This is
because no blocking restrictions of Figure \ref{blocking} are violated.

\subsubsection{Ensuring the ordering requirements:}
There are no ordering requirements between requests sent from the same source
to the same destination according to Figure \ref{order}.  However, requests
should not overtake responses to the same address, because of Requirement
\ref{reqNoOvertakeResp}. Requests and responses from a child to its parent come
on different virtual channels. Hence, maintaining Requirement
\ref{reqNoOvertakeResp} for messages from a child to its parent is difficult,
since it's difficult to guarantee point-to-point FIFO ordering of the messages
coming on different virtual channels.

Point-to-point FIFO ordering for messages from a child to its parent can be
ensured by adding more information to the messages rather than relying on the
underlying network. Each message for address $a$ from child $c$ to its parent
$p$ will contain an additional tag which specifies the state the child was in
at the time of sending the message. The new message becomes \Req{c}{p}{a}{x
\rightarrow y} or \Resp{c}{p}{a}{x \rightarrow y}, where $x$ specifies the
state of the cache at the time the request was sent. At the parent, a thread
for handling this message will be created, and this message will be removed,
only after $p.dir[c][a]$ becomes less than or equal to $x$, where $x$ is the
state of the child at the time the message was sent. The intuition behind why
this works is as follows (we do not give the formal proof here). Requests can
not be sent from a child when there is a pending response from the parent. Similarly, a response can not be sent from
a child when there is a pending response from the parent. So, a response from the parent can never be in flight
when a request or a response from the child is in flight, since the
parent only sends responses on requests from the child . So the directory state of the parent at the time of
receiving a message can never be higher than the state of the child just before
sending the message, if the message did not overtake a previous response.

One issue with this for responses is that if only one virtual channel is used
for responses from any child to its parent throughout the system is as follows.
A response sent later for an address from a child to its parent can block a
response for the same address from the same child to its parent sent earlier.
This violates Requirement \ref{cRespFifo}. If two separate virtual channel are
used, one for downgrade-to-$S$ responses ($RespChannel_S$) and one for
downgrade-to-$I$ responses ($RespChannel_I$), then using the response sent later
will not block an earlier response.

The same technique can not be used to guarantee point-to-point FIFO ordering
for transmitting messages (both requests and responses) from a parent to a
child; the intuition is that requests from the parent and a response from the
child can both be in flight at the same time since the child can voluntarily
downgrade due to evictions.  If the channel can not guarantee point-to-point
FIFO ordering, then an ACK must be sent by the child on receiving any response
from the parent to guarantee Requirements \ref{cRespFifo} and
\ref{reqNoOvertakeResp}. This ACK can use either of the channels meant for
responses from a child to its parent ($RespChannel_I$ or $RespChannel_S$).  The
protocol must change slightly; the child has to send an ACK after receiving
responses, and the parent has to wait for the ACK before freeing the thread.

This gives a total of $2N + 2$ virtual channels where $N + 1$ is the number of
levels in the cache hierarchy with the following ordering constraints:
(FIFO-ordered or ack-ordered) $ReqChannel\langle x, ToC \rangle$ for requests and
responses from a node in level $x$ to its child, unordered $ReqChannel\langle x,
ToP \rangle$ for requests from a node in level $x$ to its parent, unordered
$RespChannel_I$ for downgrade-to-$I$ responses from any node to its parent and
finally, unordered $RespChannel_S$ for downgrade-to-$S$ responses from any node
to its parent.

\subsubsection{Bits required for the directory:}
\floatstyle{plain}
\restylefloat{figure}
\begin{wrapfigure}{r}{.4\linewidth}
\begin{tabularx}{\linewidth}{|c|X|}
\hline
State & Directory \\
\hline
$M$ & one $M$, rest $I$\\
$M$ & some $S$, rest $I$\\
$S$ & some $S$, rest $I$\\
$I$ & all $I$\\
\hline
\end{tabularx}
\caption{Possible values of coherence state and directory for each cache line}
\label{encoding}
\end{wrapfigure}
The directory of a node store its version of the state for each of the node's
children. However, one can use the fact that for a node $n$, if $n.dir[c][a] =
M$, then $\forall c' \neq c, n.dir[c'][a] = I$. This comes from Invariants
\ref{singleWriter} and \ref{conservative}. Thus, storing just the index of the
cache is sufficient if $n.dir[c][a] = M$ for some cache $c$. Figure
\ref{encoding} shows the possible values of the directory and coherence state
for each line in the cache. It can clearly be seen that this requires
$max(\lceil log_2(n)\rceil, n) + 2$ bits per line, for the most efficient
encoding.
