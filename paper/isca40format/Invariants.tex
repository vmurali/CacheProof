\section{Invariants}
\label{sec:invariants}

\floatstyle{boxed}
\restylefloat{figure}

The caches are assumed to be organized in the form of a tree
(Figure~\ref{fig:hierarchy}). The leaves of this tree represent the L1 caches,
with each L1 cache connected to exactly one core. The root of the tree is a
single Last-level cache (LLC), connected to the main memory. A node can
communicate only with its parents or with its children via a request or
response message whose format is in Figure~\ref{message}.

\begin{figure}
\begin{inv}
An incoming request message from a child should not block an incoming request
message from the parent, even for a different address\label{cReqNoBlockPReq}
\end{inv}
\begin{inv}
An incoming request messages for an address $a$ should not block an incoming
response message for address $a$, even from a different
source.\label{reqNoBlockReq}
\end{inv}
\caption{Blocking restrictions}
\label{blocking}
\end{figure}

\begin{figure}
\begin{inv}
An incoming response message for an address $a$ from a child $c$ should not be
received before another incoming response message from the same $c$ and the
same $a$ sent earlier has been received\label{cRespFifo}
\end{inv}
\begin{inv}
An incoming request message for an address $a$ from a source $n$ should not be
received before another incoming response message from the same $n$ and the
same $a$ sent earlier has been received\label{reqNoOvertakeResp}
\end{inv}
\caption{Ordering requirements}
\label{order}
\end{figure}

\begin{figure}
\begin{inv}
A response \Resp{p}{c}{a}{x}, where $p = c.parent$, can be sent from $p$ only
if
\begin{enumerate}
\item a thread that handling a request from $c$ to $p$ for
address $a$ is executing, and
\item $x > p.dir[c][a]$
\end{enumerate}
\label{cSendRespPre}
\end{inv}
\begin{inv}
If a response \Resp{p}{c}{a}{x} is sent from $p$, then $p.dir[c][a] \gets x$
\label{cSendRespPost}
\end{inv}
\begin{inv}
A response \Resp{c}{p}{a}{x}, where $p = c.parent$, can be sent from $c$ only
if $x < c.state[a]$ \label{pSendRespPre1}
\end{inv}
\begin{inv}
If there is a thread in node $c$ that is waiting to receive a response from its
parent $p$ for an address $a$, then response \Resp{c}{p}{a}{x} can be sent only
on executing a thread that is handling a request from $p$ to $c$ for address
$a$. For instance, $a$ can not be evicted from $c$, if there is a thread
handling a request from $p$ to $c$ for address $a$.
\label{pSendRespPre2}
\end{inv}
\begin{inv}
If \Resp{c}{p}{a}{x} is sent $c.state[a] \gets x$
\label{pSendRespPost}
\end{inv}
\caption{Invariants for sending responses}
\label{sendResp}
\end{figure}

\begin{figure}
\begin{inv}
On receiving a response \Resp{c}{p}{a}{x}, where $p = c.parent$, $p.dir[c][a]
\gets x$
\label{pRecvResp}
\end{inv}
\begin{inv}
On receiving a response \Resp{p}{c}{a}{x}, where $p = c.parent$, $c.state[c]
\gets x$
\label{cRecvResp}
\end{inv}
\caption{Invariants for receiving responses}
\label{recvResp}
\end{figure}

\begin{figure}
\begin{inv}
$c.state[a]$ can change only on $c$ sending a response to or receiving a
response from $c.parent$
\label{cState}
\end{inv}
\begin{inv}
$p.dir[c][a]$ can change only on $p$ sending or receiving a response from
its child $c$
\label{pState}
\end{inv}
\caption{Invariants for state changes}
\label{stateChange}
\end{figure}

\begin{figure}
\begin{inv}
\Req{p}{c}{a}{x}, where $p = c.parent$, can be sent only if $x < p.dir[c][a]$
\label{pSendReqPre}
\end{inv}
\begin{inv}
\Req{c}{p}{a}{x}, where $p = c.parent$, can be sent only if $x > c.state[a]$
\label{cSendReqPre}
\end{inv}
\caption{Invariants for sending a request}
\label{sendReq}
\end{figure}

\begin{figure}
\begin{inv}
$p$ can not receive a request \Req{c}{p}{a}{x} from $c$, where $p = c.parent$,
if either
\begin{enumerate}
\item address $a$ has been chosen for eviction by some thread and that thread
has not yet replaced $a$, or
\item a thread in $p$ is handling a request for address
$a$ from any source
\end{enumerate}
\label{pHandleReq}
\end{inv}
\begin{inv}
$c$ can not receive a request \Req{p}{c}{a}{x} from $p$, where $p = c.parent$,
if either
\begin{enumerate}
\item address $a$ has been chosen for eviction by some thread and that thread
has not yet replaced $a$, or
\item a thread in $p$ is handling a request for address
$a$ from $p$, or
\item a thread in $p$ is handling a request for address
$a$ from one of $p$'s children $c'$, and that thread will not send any
(downgrade) request to any child for address $a$ anymore
\end{enumerate}
\label{cHandleReq}
\end{inv}
\caption{Invariants for receiving a request (used by the scheduler)}
\label{recvReq}
\end{figure}

\begin{figure}
\begin{inv}
Address $a$ present in node $c$ can not be chosen for eviction by a thread
executing in $c$ if either
\begin{enumerate}
\item address $a$ has been chosen for eviction by some thread and that thread
has not yet replaced $a$, or
\item a thread in $c$ is handling a request for address
$a$ from any source
\end{enumerate}
\label{evict}
\caption{Invariants for suspending a thread during choosing an address for eviction}
\end{inv}
\end{figure}

\begin{figure}
\begin{inv}
Starvation-freedom: A thread that keeps becoming ready to execute will
eventually be scheduled by the scheduler to execute.
\end{inv}
\end{figure}
