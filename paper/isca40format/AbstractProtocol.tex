\section{Abstract directory-based protocol}

\label{sec:abstract}

\newcommand{\One}[2]{\text{#1$\langle#2\rangle$}}
\newcommand{\two}[3]{\text{#1$\langle#2,#3\rangle$}}
\newcommand{\three}[4]{\text{#1$\langle#2,#3,#4\rangle$}}
\newcommand{\four}[5]{\text{#1$\langle#2,#3,#4,#5\rangle$}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\assigns}{:=}
\newcommand{\AndAnd}{\;\&\&\;}
\newcommand{\OrOr}{\;||\;}

We will give the abstract directory-based protocol for a hierarchical system of
caches. The caches are assumed to be organized in the form of a tree. The leaves
of this tree represent the L1 caches, with each L1 cache connected to exactly
one core. The root of the tree is a single Last-level cache (LLC), connected to
the main memory.

The notation we adopt is primarily for conciseness of description while allowing
maximum flexibility in the implementation. An realistic efficient implementation
would forego some of the flexibility, and we will show such implementations
later.

A node keeps information about the state of each cache line in the node as well
as in each of its children, \ie the directory. Figure~\ref{table:states} shows
the precise information that a node keeps for each cache line in the node. The
notation we adopt is primarily for conciseness of description. For instance, the
directory need not contain the exact copy of each of the child's coherence
state, for each cache line, instead the encoding can be more efficient. We will
show efficient implementations later.

\begin{figure}
\begin{tabular}{|l|p{.64\columnwidth}|}
\hline
isPresent(a) & Cache line for address $a$ is present\\
\hline
data(a) & Cache line data for address $a$\\
\hline
state(a) & Coherence state for address $a$\\
\hline
dir(a, c) & Directory's copy of the coherence state for address $a$ in child
$c$\\
\hline
isCWait(c, a) & Check if the node waiting for a response from child $c$
for address $a$\\
\hline
cWait(cm a) & The coherence state to which the node has requested child $c$ to
go to, for address $a$\\
\hline
isPWait(a) & Check if the node waiting for a response from its parent for
address $a$\\
\hline
replacingAddr(a) & The address of the line that is going to replace the line
corresponding to address $a$\\
\hline
\end{tabular}
\caption{Information that the node keeps for a cache line}
\label{table:states}
\end{figure}

Figure~\ref{table:messages} shows the incoming and outgoing messages to and from
the node, respectively.

\begin{figure}
\begin{tabular}{|l|p{.6\columnwidth}|}
\hline
\multicolumn{2}{|c|}{Incoming messages}\\
\hline
\three{ReqFromC}{c}{a}{x} & Request from child $c$ upgrade $c$'s coherence
state for address $a$ to $x$\\
\two{ReqFromP}{a}{x} & Request from parent to downgrade node's coherence
state for address $a$ to $x$\\
\three{RespFromC}{c}{a}{x} & Message from child $c$ denoting that $c$'s
coherence state for address $a$ has changed to $x$\\
\three{DataFromC}{c}{a}{d} & Data $d$ of the cache line received from $c$ for
address $a$\\
\two{RespFromP}{a}{x} & Response from parent giving permission to
upgrade the node's coherence state for address $a$ to $x$\\
\two{DataFromP}{a}{d} & Data $d$ of the cache line received from parent for
address $a$\\
\hline
\multicolumn{2}{|c|}{Outgoing messages}\\
\hline
\three{ReqToC}{c}{a}{x} & Request to child $c$ to downgrade $c$'s
coherence state for address $a$ to $x$\\
\two{ReqToP}{a}{x} & Request to parent to upgrade node's coherence
state for address $a$ to $x$\\
\three{RespToC}{c}{a}{x} & Response to child $c$ granting permission to
upgrade $c'$ coherence state for address $a$ to $x$\\
\three{DataToC}{c}{a}{d} & Data $d$ of the cache line sent to the child
$c$ for address $a$\\
\two{RespToP}{a}{x} & Message to parent denoting that the node's
coherence state for address $a$ has changed to $x$\\
\two{DataToP}{c}{d} & Data $d$ of the cache line sent to the parent
for address $a$\\
\hline
\multicolumn{2}{|c|}{Eviction messages}\\
\hline
\One{EvictReq}{a} & Request to evict cache line for address $a$ (generated by
the node itself)\\
\hline
\end{tabular}
\caption{Incoming, outgoing and eviction messages}
\label{table:messages}
\end{figure}

Each message coming from a particular child or the parent is independent of the
messages coming from another source, in addition to being independent of the
messages for a different address. The node can process messages coming from
different sources, and for different addresses in any order. \emph{ A response
or a request should not be handled before handling an earlier response for the
same address from the same source}. Even though our abstract protocol requires
this ordering, we later show that is easy to enforce these even if the
underlying network doesn't enforce point-to-point FIFO ordering or priorities
between different kinds of messages.

Evicting a cache line for replacement can also be treated as a request message,
albeit generated internally by the node. Such a request would be generated if a
cache line requested by a child is currently not present in the cache, and some
other cache line has to be evicted to make room for the requested cache line. 

To allow maximum flexibility of implementation, the node is given separate
access queues for each kind of message (request of response) from each source
and for each address. An implementation of a protocol using our methodology does
not have to keep a separate access queue for each source and each address, but
it must adhere to the following rules: \emph{\emph{a)} a request from any child
should not block a request from the parent, and \emph{b)} no request should
block any response}. As we show later, these rules are necessary to avoid
deadlocks. This flexibility allows one to design a wide range of blocking
policy.

The values of the coherence state (and hence the directory state) belong to a
totally ordered set, \ie a set in which a \emph{less than} ($<$) relation is
defined between every pair of elements in that set. If a line is not present,
then the state of the line is the least value in this totally ordered set, for
comparison purposes. Let us call this least value as $Inv$, a shorthand for
Invalid. Typically, a line in state $Inv$ signifies no permissions.

We now describe the procedures for a node to handle requests and responses. Note
that a message handler would be triggered only if the corresponding message is
present.  Similarly, if the required resources for handling a message are not
present (for example, if the handling of the request from a child requires
sending further requests to its children or the parent, and the send buffers are
full), then the handler for request from a child would not be triggered.

Figure~\ref{alg:handlePReq} specifies how to handle a node's incoming request
from the parent for downgrading the coherence state of address $a$ to $x$.

Function $hasDataXfer(x, y)$ specifies whether data has to be transferred
from a node to its parent when the node downgrades the coherence state of some
line from $x$ to $y$.  This function is used at the node to determine if the
child has transferred data or not on receiving a response from the child, and
also to determine if the node has to send data to the parent, for processing a
request from the parent. In a typical coherence protocol, the data has to be
only transferred by a node to its parent if the cache line has been modified.

\floatstyle{boxed} 
\restylefloat{figure}

\begin{figure}
\begin{algorithmic}
\Function{handlePReq}{\two{ReqFromP}{a}{x}}
\If {$!isPresent(a)$}
  \State remove$(\two{ReqFromP}{a}{x})$
\ElsIf {$\forall c, !isCWait(c, a)$}
  \If {$state(a) \le x$}
     \State remove$(\two{ReqFromP}{a}{x})$
  \ElsIf {$\forall c, dir(c, a) \le x$}
     \State remove$(\two{ReqFromP}{a}{x})$
     \If {hasDataXfer$(state(a), x)$}
        \State send$(\two{DataToP}{a}{data(a)})$
     \EndIf
     \State $state(a) \assigns x$
     \State send$(\two{RespToP}{a}{x})$
  \Else
     \ForAll{$c$}
        \If {$dir(c, a) > x$}
           \State $isCWait(c, a) \assigns \True$
           \State $cWait(c, a) \assigns x$
           \State send$(\three{ReqToC}{c}{a}{x})$
        \EndIf
     \EndFor
  \EndIf
\EndIf
\EndFunction
\end{algorithmic}
\caption{Handle request from parent}
\label{alg:handlePReq}
\end{figure}

Figure~\ref{alg:handlePResp} specifies how to handle a node's incoming response
from the parent for upgrading the coherence state of address $a$ to $x$.

\begin{figure}
\begin{algorithmic}
\Function{handlePResp}{\two{RespFromP}{a}{x}}
  \State remove$(\two{RespFromP}{a}{x})$
  \If {$state(a) \neq Inv$}
     \State remove$(\two{DataFromP}{a}{d})$
     \State $data(a) = d$
  \EndIf
  \State $state(a) \assigns x$
  \State $isPWait(a) \assigns \False$ 
\EndFunction
\end{algorithmic}
\caption{Handle response from parent}
\label{alg:handlePResp}
\end{figure}

Figure~\ref{alg:handleCResp} specifies how to handle a node's incoming response
from a child for downgrading the child's coherence state for address $a$ to $x$.

\begin{figure}
\begin{algorithmic}
\Function{handleCResp}{\three{RespFromC}{c}{a}{x}}
  \State remove$(\two{RespFromC}{c}{a}{x})$
  \If {hasDataXfer$(dir(c,a), x)$}
     \State remove$(\two{DataFromC}{c}{a}{d})$
     \State $data(a) = d$
  \EndIf
  \State $dir(c,a) \assigns x$
  \If {$isCWait(c, a) \AndAnd cWait(c, a) >= x$}
    \State $isCWait(c, a) \assigns \False$
  \EndIf
\EndFunction
\end{algorithmic}
\caption{Handle response from child}
\label{alg:handleCResp}
\end{figure}

Figure~\ref{alg:handleCReq} specifies how to handle a node's incoming request
from a child for upgrading the child's coherence state for address $a$ to $x$.

Function \emph{compatible(x)} gives the highest state that a line in another
cache can be in without violating coherency if the line is in one cache in state
$x$. For example, the highest state that is compatible with a state having
read-write permissions is the state having no permissions (\ie $Inv$).

Function \emph{getReplace(a)} gives the address of the line that can be replaced
in order to accommodate the line in address $a$. However, if a line is waiting
for a response (from either a child or the parent), then that line can not be
replaced (ensured by the check for $isCWait$ and $isPWait$) in the pseudo-code.

\begin{figure}
\begin{algorithmic}
\Function{handleCReq}{\three{ReqFromC}{c}{a}{x}}
  \If {$isPresent(a)$}
     \If {$!isPWait(a)\ \AndAnd \forall c, !isCWait(c, a)$}
        \If {$state(a) \ge x \AndAnd$ \\
              \hspace{2.5cm} $\forall c' \neq c, dir(c', a) \le \text{compatible}(x)$}
           \State remove$(\three{ReqFromC}{c}{a}{x})$
           \If {$dir(c,a) \neq Inv)$}
              \State send$(\three{DataToC}{c}{a}{data(a)})$
           \EndIf
           \State $dir(c, a) \assigns x$
           \State send$(\three{RespToC}{c}{a}{x})$
        \Else
           \If {$state(a) < x$}
              \State $isPWait(a) \assigns \True$
              \State send$(\two{ReqToP}{a}{x})$
           \EndIf
           \ForAll {$c' \neq c$}
              \If {$dir(c', a) > \text{compatible}(x)$}
                 \State $isCWait(c', a) \assigns \True$
                 \State $cWait(c', a) \assigns \text{compatible}(x)$
                 \State send$(\three{ReqToC}{c'}{a}{\text{compatible}(x)})$
              \EndIf
           \EndFor
        \EndIf
     \EndIf
  \Else
     \State \textbf{let} $a' = \text{getReplace}(a)$
     \If {$!isPWait(a') \AndAnd !isCWait(a')$}
        \State $replacingAddr(a') \assigns a$
        \State send$(\One{EvictReq}{a'})$
     \EndIf
  \EndIf
\EndFunction
\end{algorithmic}
\caption{Handle request from child}
\label{alg:handleCReq}
\end{figure}

Figure~\ref{alg:handleEvict} specifies how to handle an eviction message (in
order to replace the current line in address $a$ with the line for some other
address, which is given by $replacingAddr(a)$).
\begin{figure}
\begin{algorithmic}
\Function{handleEvict}{\One{EvictReq}{a}}
   \If {$!isPresent(a) \OrOr$\\
        \hspace{3cm} $\forall c, dir(c, a) = Inv$}
      \State remove$(\One{EvictReq}{a})$
      \If {$state(a) \neq Inv$}
         \State send$(\two{RespToP}{a}{Inv})$
         \If {hasDataXfer$(state(a), Inv)$}
            \State send$(\two{RespToP}{a}{data(a)})$
         \EndIf
      \EndIf
      \State $isPresent(a) \assigns \False$
      \State $isPresent(replacingAddr(a)) \assigns \True$
   \Else
      \If {$\forall c, !isCWait(c, a)$}
         \ForAll{$c$}
            \If {$dir(c, a) > Inv$}
               \State $isCWait(c, a) \assigns \True$
               \State $cWait(c, a) \assigns Inv$
               \State send$(\three{ReqToC}{c}{a}{Inv})$
            \EndIf
         \EndFor
      \EndIf
   \EndIf
\EndFunction
\end{algorithmic}
\caption{Evict a line in address $a$}
\label{alg:handleEvict}
\end{figure}

\floatstyle{plain} 
\restylefloat{figure}

Note that the handlers continue to be triggered till the corresponding message
has been removed.

In order to avoid starvation, once a response is available, the handler for that
response must be triggered eventually.

Once a node starts handling a request from the parent, it can ignore all other
requests (from the children, or eviction requests) to the same address, till the
node has removed the request from the parent.

Similarly, once a node starts handling a request from a child, it can ignore
other requests from other children to the same address, till it has removed the
request from the child. However, it can not ignore requests from the parent to
the same address, in order to avoid deadlocks.

%The following are the messages transferred to and from the node
%For the abstract protocol, we consider a hierarchical system of caches. The
%caches are organized in the form of a tree. The leaves of this tree are the L1
%caches connected to each core, and the root of the tree is the LLC, connected to
%the main memory. Each node (leaf and non-leaf) contains several cache lines.
%For each cache line in a node, there is a tag and the coherence state of the
%line. Non-leaf nodes contain the directory of each line in addition to the
%coherence state. Each node can communicate only with its parent or children
%nodes.
%
%The directory of a cache line in a node has a copy of the coherence state of
%that cache line in each child-node. Note that the directory can use a clever bit
%encoding in order to reduce the number of bits used, but the information content
%of the directory remains the same. So, for the purposes of designing and
%verification of a protocol, our assumption about the directory state containing
%a copy of each cache state for each line is valid; only the bit counts in the
%implementation varies.
%
%The abstract protocol defines the behavior of each node, \ie the transitions of
%the directory as well as the coherence state on sending or receiving a message.
%The transitions are based on local information, \ie a node can access or modify
%only the states present in the node.
%
%The values of the coherence state (and hence the directory state) belong to a
%totally ordered set, \ie a set in which a \emph{less than} ($<$) relation is
%defined between every pair of elements in that set.
%
%We will use the following notation to specify the information associated with a
%particular cache line for address $a$.
%
%\begin{itemize}
%
%\item $data[a]$ denotes the data for address $a$.
%
%\item $state[a]$ denotes the coherence state of address $a$.
%
%\item $dir[a](c)$ denotes the directory's copy of the coherence state of address
%$a$ in cache $c$.
%
%\item $tag[a]$ denotes the tag of address $a$.
%
%\item $isCWait[a]$ denotes if the node is waiting for a response from any of its
%child regarding address $a$.
%
%\item $cWait[a]$ denotes the request that a node has sent its children for
%address $a$ and hence waiting for a response.
%
%\item $isPWait[a]$ denotes if the node is waiting for a response from its parent
%regarding address $a$.
%
%\item $pWait[a]$ denotes the request that a node has sent its parent for address
%$a$ and hence waiting for a response.
%
%\end{itemize}
%
%Each node sends requests and responses to its children and its parent to
%orchestrate changing of coherence states. Requests are sent to a node's parent
%for upgrading the coherence state of a line in that node, and to the node's
%children to downgrade the coherence states of the corresponding children.
%Responses received from a parent signify that the directory in the parent has
%been upgraded appropriately for that cache. Responses received from a child
%signify that the coherence state of the child has been downgraded appropriately.
%Each message coming from a particular child or the parent is independent of the
%messages coming from another source, in addition to being independent of the
%messages for a different address. The node can process messages coming from
%different sources, and for different addresses in any order. From the same
%source and for the same address, we assume that neither a response not a request
%can not overtake an earlier response
%
%Even though our abstract protocol requires these message orderings, we later
%show that is easy to enforce these even if the underlying network doesn't
%enforce point-to-point FIFO ordering or priorities between different kinds of
%messages.
%
%To allow maximum flexibility of implementation, the node has separate access
%queues for each kind of message (request of response) from each source and for
%each address. An implementation of a protocol using our methodology does not
%have to keep a separate access queue for each source and each address, but it
%has to adhere to the following rules: a) a request from any child should not
%cause head-of-line blocking of a request from a parent, and b) no request should
%cause head-of-line blocking of any response. As we show later, these rules are
%necessary to avoid deadlocks. This flexibility allows one to use a wide range of
%blocking policy.
%
%The following notation will be used for the requests and responses sent and
%received:
%
%\begin{itemize}
%
%\item $p.sendReq(a, to)$ denotes sending a request to the parent
%in order to upgrade the coherence state of address $a$ in the node to state
%$to$.
%
%\item $c.sendReq(a, to)$ denotes sending a request to child $c$ in order to
%downgrade the coherence state of address $a$ in the $c$ to state $to$.
%
%\item $p.sendResp(a, to, d)$ denotes sending a response message to the parent
%signifying that the coherence state of the node for address $a$ has changed to
%$to$. $d$ denotes the cache line sent (if necessary) by the node to the parent.
%
%\item $c.sendResp(a, to, d)$ denotes sending a response message to child $c$
%signifying that the directory state of the node for address $a$ and child $c$
%has changed to $to$. $d$ denotes the cache line sent (if necessary) by the node
%to child $c$.
%
%\item $p.peekReq[a]$ denotes the request from the parent for address $a$. The
%message contains the value of the coherence state for address $a$ that this node
%should downgrade to.
%
%\item $c.peekReq[a]$ denotes the request from child $c$ for address $a$. The
%message contains the value of the coherence state for address $a$ that child $c$
%wants to upgrade to.
%
%\item $p.deqReq[a]$ denotes finishing up of the processing of the request from
%the parent for address $a$ and hence removing the request.
%
%\item $c.deqReq[a]$ denotes finishing up of the processing of the request from
%child $c$ for address $a$ and hence removing the request.
%
%\item $p.peekResp[a]$ denotes the response from the parent for address $a$. The
%message contains a pair $\langle to, d\rangle$, where $to$ denotes the value of
%the coherence state for address $a$ that this node should upgrade to, and $d$
%represents the cache line data sent by the parent (if necessary)
%
%\item $c.peekResp[a]$ denotes the response from child $c$ for address $a$. The
%message contains a pair $\langle to, d\rangle$, where $to$ denotes the value of
%the coherence state for address $a$ that child $c$ has downgraded to, and $d$
%represents the cache line data sent by the child (if necessary)
%
%\item $p.deqReq[a]$ denotes finishing up of the processing of the response from
%the parent for address $a$ and hence removing the response.
%
%\item $c.deqReq[a]$ denotes finishing up of the processing of the response from
%child $c$ for address $a$ and hence removing the response.
%
%\end{itemize}
%
