\section{Abstract directory-based protocol}

\label{sec:abstract}

\newcommand{\One}[2]{\text{#1$\langle#2\rangle$}}
\newcommand{\two}[3]{\text{#1$\langle#2,#3\rangle$}}
\newcommand{\three}[4]{\text{#1$\langle#2,#3,#4\rangle$}}
\newcommand{\four}[5]{\text{#1$\langle#2,#3,#4,#5\rangle$}}
\newcommand{\True}{\texttt{True}}
\newcommand{\False}{\texttt{False}}
\newcommand{\assigns}{:=}
\newcommand{\AndAnd}{\;\&\&\;}
\newcommand{\OrOr}{\;||\;}
\newcommand{\Inv}{\text{$Inv$}}

\definecolor{trig-color}{gray}{.6}

We will give the abstract directory-based protocol for a hierarchical system of
caches. The caches are assumed to be organized in the form of a tree. The leaves
of this tree represent the L1 caches, with each L1 cache connected to exactly
one core. The root of the tree is a single Last-level cache (LLC), connected to
the main memory.

The notation we adopt is primarily for conciseness of description while allowing
maximum flexibility in the implementation.

A node keeps information about the state of each cache line in the node as well
as in each of its children, \ie the directory. Figure~\ref{table:states} shows
the precise information that a node keeps for each cache line in the node. The
notation we adopt is primarily for conciseness of description. For instance, the
directory need not contain the exact copy of each of the child's coherence
state, for each cache line, instead the encoding can be more efficient. We will
show efficient implementations later.

\begin{figure}
\begin{tabular}{|l|p{.64\columnwidth}|}
\hline
isPresent(a) & Check if cache line for address $a$ is present\\
\hline
data(a) & Cache line data for address $a$\\
\hline
state(a) & Coherence state for address $a$\\
\hline
dir(a, c) & Directory's copy of the coherence state for address $a$ in child
$c$\\
\hline
isCWait(c, a) & Check if the node waiting for a response from child $c$
for address $a$\\
\hline
cWait(c, a) & The coherence state to which the node has requested child $c$ to
go to, for address $a$\\
\hline
isPWait(a) & Check if the node waiting for a response from its parent for
address $a$\\
\hline
replacingAddr(a) & The address of the line that is going to replace the line
corresponding to address $a$\\
\hline
whoTrigger(a) & The source of the request which made the node wait for a
response. It is $None, Parent, Child \text{ or } Evict$\\
\hline
childTrigger(a) & If $whoTrigger(a)$ is $Child$, the index of the child which
is the source of the request\\
\hline
\end{tabular}
\caption{Information that the node keeps for a cache line}
\label{table:states}
\end{figure}

The values of the coherence state (and hence the directory state) belong to a
totally ordered set, \ie a set in which a \emph{less than} ($<$) relation is
defined between every pair of elements in that set and that relation is
transitive. For instance, in an MSI protocol, the values of the coherence state
are from the set $\{M, S, I\}$ where $I < S$, $S < M$ and $I < M$. Our abstract
protocol does not assign any semantics or meaning to the values of the coherence
states. In a concrete cache coherence protocol, the values of the states are
associated with permissions for reading and writing, and the state with fewer
permissions is $<$ the state with more permissions. We use \Inv to denote the
least element in the set containing the values of the coherence state.
Typically, this denotes that the node has no permissions for reading or writing
that line.

In order to increase the coherence state of a cache line, a node has to send an
\emph{upgrade request} to its parent and may eventually get an \emph{upgrade
response} from the parent. In order to decrease the coherence state of a cache
line for one of the node's children, the node has to send a \emph{downgrade
request} to that child, and may eventually get a \emph{downgrade response} from
that child.

Figure~\ref{table:messages} shows the incoming and outgoing messages to and from
the node, respectively, and requests for eviction. An eviction request for an
address is generated if a child has made a request for a different cache line
whose address is not currently present in the cache.

\begin{figure}
\begin{tabular}{|l|p{.6\columnwidth}|}
\hline
\multicolumn{2}{|c|}{Incoming messages}\\
\hline
\three{ReqFromC}{c}{a}{x} & Request from child $c$ upgrade $c$'s coherence
state for address $a$ to $x$\\
\two{ReqFromP}{a}{x} & Request from parent to downgrade node's coherence
state for address $a$ to $x$\\
\three{RespFromC}{c}{a}{x} & Message from child $c$ denoting that $c$'s
coherence state for address $a$ has changed to $x$\\
\three{DataFromC}{c}{a}{d} & Data $d$ of the cache line received from $c$ for
address $a$\\
\two{RespFromP}{a}{x} & Response from parent giving permission to
upgrade the node's coherence state for address $a$ to $x$\\
\two{DataFromP}{a}{d} & Data $d$ of the cache line received from parent for
address $a$\\
\hline
\multicolumn{2}{|c|}{Outgoing messages}\\
\hline
\three{ReqToC}{c}{a}{x} & Request to child $c$ to downgrade $c$'s
coherence state for address $a$ to $x$\\
\two{ReqToP}{a}{x} & Request to parent to upgrade node's coherence
state for address $a$ to $x$\\
\three{RespToC}{c}{a}{x} & Response to child $c$ granting permission to
upgrade $c'$ coherence state for address $a$ to $x$\\
\three{DataToC}{c}{a}{d} & Data $d$ of the cache line sent to the child
$c$ for address $a$\\
\two{RespToP}{a}{x} & Message to parent denoting that the node's
coherence state for address $a$ has changed to $x$\\
\two{DataToP}{c}{d} & Data $d$ of the cache line sent to the parent
for address $a$\\
\hline
\multicolumn{2}{|c|}{Eviction messages}\\
\hline
\One{EvictReq}{a} & Request to evict cache line for address $a$ (generated by
the node itself)\\
\hline
\end{tabular}
\caption{Incoming, outgoing and eviction messages}
\label{table:messages}
\end{figure}

\floatstyle{boxed} 
\restylefloat{figure}

\begin{figure}
\begin{minipage}{\columnwidth}
\begin{enumerate}
\item A request or a response should not be handled before handling an earlier
response for the same address from the same source

\item A request from a child for an address should not block or prevent the
handling of a request from the parent for the same address

\item A request for an address should not block or prevent the handling of a
response from any source for any address
\end{enumerate}
\end{minipage}
\caption{Message ordering, and blocking restrictions}
\label{list:messageOrder}
\end{figure}

\floatstyle{plain} 
\restylefloat{figure}

Each message coming from a particular child or the parent is independent of the
messages coming from another source, in addition to being independent of the
messages for a different address. The node can process messages coming from
different sources, and for different addresses in any order, subject to the
ordering requirements in Figure~\ref{list:messageOrder}. We later show that is
easy to enforce this ordering even if the underlying network doesn't enforce
point-to-point FIFO ordering or priorities between different kinds of messages.

To allow maximum flexibility of implementation, the node is given separate
access queues for each kind of message (request of response) from each source
and for each address. An implementation of a protocol using our methodology does
not have to keep a separate access queue for each source and each address, but
it must adhere to the blocking restrictions in Figure~\ref{list:messageOrder}.
These restrictions are necessary to avoid deadlocks. The flexibility of the
abstract protocol allows one to design a wide range of blocking policies.

Our abstract protocol also depends on the designer correctly defining the three
functions shown in Figure~\ref{table:functions}. These functions abstract away
the coherence aspect of the cache coherence protocol. Note that $maxCompat$
function can be derived from $isCompat$ function, if $isCompat$ is defined
correctly. Figure~\ref{fig:msiFunc} shows the functions defined for MSI (--
denotes undefined).

\begin{figure}
\begin{tabular}{|c|p{.63\columnwidth}|}
\hline
isCompat(x, y) & Checks if two different caches can have coherence states
$x$ and $y$, respectively, for the same address\\
\hline
maxCompat(x) & Returns a coherence state value $y$ such that, $\forall z \le y,
isCompat(x, z)$ and $\forall w > y, !isCompat(x, w)$\\
\hline
dataXfer(x, y) & Checks if cache line data has to be transferred by a cache to its
parent on downgrading from $x$ to $y$\\
\hline
\end{tabular}
\caption{Functions to abstract away the coherence aspect}
\label{table:functions}
\end{figure}

\begin{figure}
\centering
\begin{subfigure}{.45\columnwidth}
\centering
\begin{tabular}{|c||c|c|c|}
\hline
& I & S & M\\
\hline\hline
I & $\checkmark$ & $\checkmark$ & $\checkmark$\\
\hline
S & $\checkmark$ & $\checkmark$ & $\times$\\
\hline
M & $\checkmark$ & $\times$ & $\times$\\
\hline
\end{tabular}
\label{table:isCompat}
\caption{$isCompat$ for MSI}
\end{subfigure}
\quad
\begin{subfigure}{.45\columnwidth}
\centering
\begin{tabular}{|c||c|c|c|}
\hline
\backslashbox{$x$}{$y$} & I & S & M\\
\hline\hline
I & -- & -- & --\\
\hline
S & $\times$ & -- & --\\
\hline
M & $\checkmark$ & $\checkmark$ & --\\
\hline
\end{tabular}
\label{table:dataXfer}
\caption{$dataXfer(x, y)$ for MSI}
\end{subfigure}
\caption{Coherence abstraction for MSI}
\label{fig:msiFunc}
\end{figure}

We now describe the procedures for a node to handle requests and responses. Note
that a message handler would be triggered only if the corresponding message is
present. If the required resources for handling a message are not present (for
example, if the handling of the request from a child requires sending further
requests to its children or the parent, and the send buffers are full), then the
handler for request from a child would not be triggered.

Figure~\ref{alg:handlePReq} specifies how to handle a node's incoming request
from the parent for downgrading the coherence state of address $a$ to $x$. Note
that a request from the parent can be handled successfully only if the node is
not already waiting for a response from a child.

Figure~\ref{alg:handleCReq} specifies how to handle a node's incoming request
from a child for upgrading the child's coherence state for address $a$ to $x$.
Note that a request from a child can be handled successfully only if the node is
not already waiting for a response from the parent or from any child.

Figure~\ref{alg:handlePResp} specifies how to handle a node's incoming response
from the parent for upgrading the coherence state of address $a$ to $x$.

Figure~\ref{alg:handleCResp} specifies how to handle a node's incoming response
from a child for downgrading the child's coherence state for address $a$ to $x$.

Figure~\ref{alg:handleEvict} specifies how to handle an eviction message (in
order to replace the current line in address $a$ with the line for some other
address, which is given by $replacingAddr(a)$).

\floatstyle{boxed} 
\restylefloat{figure}

\begin{figure}
\begin{algorithmic}
\Rule{handlePReq}{\two{ReqFromP}{a}{x}}
\If {$!isPresent(a)$}
  \State remove$(\two{ReqFromP}{a}{x})$
\ElsIf {$\forall c, !isCWait(c, a)$}
  \If {$state(a) \le x$}
     \State remove$(\two{ReqFromP}{a}{x})$
  \ElsIf {$\forall c, dir(c, a) \le x$}
     \State remove$(\two{ReqFromP}{a}{x})$
     \If {dataXfer$(state(a), x)$}
        \State send$(\two{DataToP}{a}{data(a)})$
     \EndIf
     \State $state(a) \assigns x$
     \State send$(\two{RespToP}{a}{x})$
  \Else
     \ForAll{$c$}
        \If {$dir(c, a) > x$}
           \State $isCWait(c, a) \assigns \True$
           \State $cWait(c, a) \assigns x$
           \State send$(\three{ReqToC}{c}{a}{x})$
        \EndIf
     \EndFor
     \State \textcolor{trig-color}{$whoTrigger(a) \assigns Parent$}
  \EndIf
\EndIf
\EndRule
\end{algorithmic}
\caption{Handle request from parent}
\label{alg:handlePReq}
\end{figure}

\begin{figure}
\begin{algorithmic}
\Rule{handleCReq}{\three{ReqFromC}{c}{a}{x}}
  \If {$isPresent(a)$}
     \If {$!isPWait(a)\ \AndAnd \forall c, !isCWait(c, a)$}
        \If {$state(a) \ge x \AndAnd$ \\
              \hspace{2.5cm} $\forall c' \neq c, dir(c', a) \le \text{maxCompat}(x)$}
           \State remove$(\three{ReqFromC}{c}{a}{x})$
           \If {$dir(c,a) \neq \Inv)$}
              \State send$(\three{DataToC}{c}{a}{data(a)})$
           \EndIf
           \State $dir(c, a) \assigns x$
           \State send$(\three{RespToC}{c}{a}{x})$
        \Else
           \If {$state(a) < x$}
              \State $isPWait(a) \assigns \True$
              \State send$(\two{ReqToP}{a}{x})$
           \EndIf
           \ForAll {$c' \neq c$}
              \If {$dir(c', a) > \text{maxCompat}(x)$}
                 \State $isCWait(c', a) \assigns \True$
                 \State $cWait(c', a) \assigns \text{maxCompat}(x)$
                 \State send$(\three{ReqToC}{c'}{a}{\text{maxCompat}(x)})$
              \EndIf
           \EndFor
           \State \textcolor{trig-color}{$whoTrigger(a) \assigns Child$}
           \State \textcolor{trig-color}{$childTrigger(a) \assigns c$}
        \EndIf
     \EndIf
  \Else
     \State \textbf{let} $a' \assigns \text{getReplace}(a)$
     \If {$!isPWait(a') \AndAnd !isCWait(a')$}
        \State $replacingAddr(a') \assigns a$
        \State send$(\One{EvictReq}{a'})$
        \State \textcolor{trig-color}{$whoTrigger(a) \assigns Evict$}
        \State \textcolor{trig-color}{$childTrigger(a) \assigns c$}
     \EndIf
  \EndIf
\EndRule
\end{algorithmic}
\caption{Handle request from child}
\label{alg:handleCReq}
\end{figure}

\begin{figure}
\begin{algorithmic}
\Rule{handleEvict}{\One{EvictReq}{a}}
   \If {$!isPresent(a) \OrOr \forall c, dir(c, a) = \Inv$}
      \State remove$(\One{EvictReq}{a})$
      \If {$state(a) \neq \Inv$}
         \State send$(\two{RespToP}{a}{\Inv})$
         \If {dataXfer$(state(a), \Inv)$}
            \State send$(\two{RespToP}{a}{data(a)})$
         \EndIf
      \EndIf
      \State $isPresent(a) \assigns \False$
      \State allocLine$(replacingAddr(a))$
      \State \textcolor{trig-color}{\textbf{trigger} handleCReq($childTrigger(a)$)}
   \Else
      \If {$\forall c, !isCWait(c, a)$}
         \ForAll{$c$}
            \If {$dir(c, a) > \Inv$}
               \State $isCWait(c, a) \assigns \True$
               \State $cWait(c, a) \assigns \Inv$
               \State send$(\three{ReqToC}{c}{a}{\Inv})$
            \EndIf
         \EndFor
      \EndIf
   \EndIf
\EndRule
\end{algorithmic}
\caption{Evict a line in address $a$}
\label{alg:handleEvict}
\end{figure}

\begin{figure}
\begin{algorithmic}
\Rule{handlePResp}{\two{RespFromP}{a}{x}}
  \State remove$(\two{RespFromP}{a}{x})$
  \If {$state(a) \neq \Inv$}
     \State remove$(\two{DataFromP}{a}{d})$
     \State $data(a) = d$
  \EndIf
  \State $state(a) \assigns x$
  \State $isPWait(a) \assigns \False$ 
  \State \textcolor{trig-color}{\textbf{trigger} handleCReq($childTrigger(a)$)}
\EndRule
\end{algorithmic}
\caption{Handle response from parent}
\label{alg:handlePResp}
\end{figure}

\begin{figure}
\begin{algorithmic}
\Rule{handleCResp}{\three{RespFromC}{c}{a}{x}}
  \State remove$(\two{RespFromC}{c}{a}{x})$
  \If {dataXfer$(dir(c,a), x)$}
     \State remove$(\two{DataFromC}{c}{a}{d})$
     \State $data(a) = d$
  \EndIf
  \State $dir(c,a) \assigns x$
  \If {$isCWait(c, a) \AndAnd cWait(c, a) >= x$}
    \State $isCWait(c, a) \assigns \False$
  \EndIf
  {\color{trig-color}
  \If {$whoTrigger(a) = Parent$}
     \State \textbf{trigger} handlePReq
  \ElsIf {$whoTrigger(a) = Evict$}
     \State \textbf{trigger} handleEvict
  \ElsIf {$whoTrigger(a) = Child$}
     \State \textbf{trigger} handleCReq($childTrigger(a)$)
  \EndIf}
\EndRule
\end{algorithmic}
\caption{Handle response from child}
\label{alg:handleCResp}
\end{figure}

Function \emph{getReplace(a)} gives the address of the line that can be replaced
in order to accommodate the line in address $a$. Note that if the line selected
for eviction is waiting for a response from the parent or from any child, then
it can not be replaced.

Figure~\ref{alg:allocLine} shows the initiation that has to happen for
allocating a new cache line for an address.

\begin{figure}
\begin{algorithmic}
\Procedure{allocLine}{$a$}
  \State $isPresent(a) \assigns \True$
  \State \textcolor{trig-color}{$whoTrigger(a) \assigns None$}
  \State $state(a) \assigns \Inv$
  \ForAll {$c$}
     \State $dir(c, a) \assigns \Inv$
  \EndFor
  \State $isCWait(a) \assigns \False$
  \State $isPWait(a) \assigns \False$
\EndProcedure
\end{algorithmic}
\caption{Allocate a new cache line for address $a$}
\label{alg:allocLine}
\end{figure}

\floatstyle{plain} 
\restylefloat{figure}

Each handler will be triggered repeatedly till the corresponding message has
been removed. In order to avoid starvation, the following two conditions must be
maintained:
\begin{enumerate}
\item Once a response is available from any source, the handler for that
response must be triggered eventually.
\item After handling a response (or an evict request) the corresponding handler
must trigger the original handler that requested the received response (or made
an eviction request). The $whoTrigger(a)$ keeps track of the original handler
for each address $a$. In case of a $Child$ trigger, the actual child
corresponding to the original handler is kept track of in $childTrigger(a)$, for
address $a$, in which case $handleCReq$ is triggered for the outstanding request
from that child. In the figures, the code corresponding to this is grayed out
\end{enumerate}


%The following are the messages transferred to and from the node
%For the abstract protocol, we consider a hierarchical system of caches. The
%caches are organized in the form of a tree. The leaves of this tree are the L1
%caches connected to each core, and the root of the tree is the LLC, connected to
%the main memory. Each node (leaf and non-leaf) contains several cache lines.
%For each cache line in a node, there is a tag and the coherence state of the
%line. Non-leaf nodes contain the directory of each line in addition to the
%coherence state. Each node can communicate only with its parent or children
%nodes.
%
%The directory of a cache line in a node has a copy of the coherence state of
%that cache line in each child-node. Note that the directory can use a clever bit
%encoding in order to reduce the number of bits used, but the information content
%of the directory remains the same. So, for the purposes of designing and
%verification of a protocol, our assumption about the directory state containing
%a copy of each cache state for each line is valid; only the bit counts in the
%implementation varies.
%
%The abstract protocol defines the behavior of each node, \ie the transitions of
%the directory as well as the coherence state on sending or receiving a message.
%The transitions are based on local information, \ie a node can access or modify
%only the states present in the node.
%
%The values of the coherence state (and hence the directory state) belong to a
%totally ordered set, \ie a set in which a \emph{less than} ($<$) relation is
%defined between every pair of elements in that set.
%
%We will use the following notation to specify the information associated with a
%particular cache line for address $a$.
%
%\begin{itemize}
%
%\item $data[a]$ denotes the data for address $a$.
%
%\item $state[a]$ denotes the coherence state of address $a$.
%
%\item $dir[a](c)$ denotes the directory's copy of the coherence state of address
%$a$ in cache $c$.
%
%\item $tag[a]$ denotes the tag of address $a$.
%
%\item $isCWait[a]$ denotes if the node is waiting for a response from any of its
%child regarding address $a$.
%
%\item $cWait[a]$ denotes the request that a node has sent its children for
%address $a$ and hence waiting for a response.
%
%\item $isPWait[a]$ denotes if the node is waiting for a response from its parent
%regarding address $a$.
%
%\item $pWait[a]$ denotes the request that a node has sent its parent for address
%$a$ and hence waiting for a response.
%
%\end{itemize}
%
%Each node sends requests and responses to its children and its parent to
%orchestrate changing of coherence states. Requests are sent to a node's parent
%for upgrading the coherence state of a line in that node, and to the node's
%children to downgrade the coherence states of the corresponding children.
%Responses received from a parent signify that the directory in the parent has
%been upgraded appropriately for that cache. Responses received from a child
%signify that the coherence state of the child has been downgraded appropriately.
%Each message coming from a particular child or the parent is independent of the
%messages coming from another source, in addition to being independent of the
%messages for a different address. The node can process messages coming from
%different sources, and for different addresses in any order. From the same
%source and for the same address, we assume that neither a response not a request
%can not overtake an earlier response
%
%Even though our abstract protocol requires these message orderings, we later
%show that is easy to enforce these even if the underlying network doesn't
%enforce point-to-point FIFO ordering or priorities between different kinds of
%messages.
%
%To allow maximum flexibility of implementation, the node has separate access
%queues for each kind of message (request of response) from each source and for
%each address. An implementation of a protocol using our methodology does not
%have to keep a separate access queue for each source and each address, but it
%has to adhere to the following rules: a) a request from any child should not
%cause head-of-line blocking of a request from a parent, and b) no request should
%cause head-of-line blocking of any response. As we show later, these rules are
%necessary to avoid deadlocks. This flexibility allows one to use a wide range of
%blocking policy.
%
%The following notation will be used for the requests and responses sent and
%received:
%
%\begin{itemize}
%
%\item $p.sendReq(a, to)$ denotes sending a request to the parent
%in order to upgrade the coherence state of address $a$ in the node to state
%$to$.
%
%\item $c.sendReq(a, to)$ denotes sending a request to child $c$ in order to
%downgrade the coherence state of address $a$ in the $c$ to state $to$.
%
%\item $p.sendResp(a, to, d)$ denotes sending a response message to the parent
%signifying that the coherence state of the node for address $a$ has changed to
%$to$. $d$ denotes the cache line sent (if necessary) by the node to the parent.
%
%\item $c.sendResp(a, to, d)$ denotes sending a response message to child $c$
%signifying that the directory state of the node for address $a$ and child $c$
%has changed to $to$. $d$ denotes the cache line sent (if necessary) by the node
%to child $c$.
%
%\item $p.peekReq[a]$ denotes the request from the parent for address $a$. The
%message contains the value of the coherence state for address $a$ that this node
%should downgrade to.
%
%\item $c.peekReq[a]$ denotes the request from child $c$ for address $a$. The
%message contains the value of the coherence state for address $a$ that child $c$
%wants to upgrade to.
%
%\item $p.deqReq[a]$ denotes finishing up of the processing of the request from
%the parent for address $a$ and hence removing the request.
%
%\item $c.deqReq[a]$ denotes finishing up of the processing of the request from
%child $c$ for address $a$ and hence removing the request.
%
%\item $p.peekResp[a]$ denotes the response from the parent for address $a$. The
%message contains a pair $\langle to, d\rangle$, where $to$ denotes the value of
%the coherence state for address $a$ that this node should upgrade to, and $d$
%represents the cache line data sent by the parent (if necessary)
%
%\item $c.peekResp[a]$ denotes the response from child $c$ for address $a$. The
%message contains a pair $\langle to, d\rangle$, where $to$ denotes the value of
%the coherence state for address $a$ that child $c$ has downgraded to, and $d$
%represents the cache line data sent by the child (if necessary)
%
%\item $p.deqReq[a]$ denotes finishing up of the processing of the response from
%the parent for address $a$ and hence removing the response.
%
%\item $c.deqReq[a]$ denotes finishing up of the processing of the response from
%child $c$ for address $a$ and hence removing the response.
%
%\end{itemize}
%
