\newcommand{\fourAngle}[5]{\text{$#1\langle#2,#3,#4,#5\rangle$}}
\newcommand{\ReqCore}[4]{\fourAngle{Req}{#1}{#2}{#3}{#4}}

\subsection{Atomic MSI protocol for 2-levels, no replacement evictions}

XXXXXX: This subsection is probably not going to go into the paper, since it's
too obvious. The definitions have been repeated in the later subsections.

We start with an atomic MSI protocol, with two levels of the memory hierarchy --
the L1 caches and the main memory. In this atomic protocol, the memory
controller can read and write the coherence states as well as the data of each
address present in the L1 caches. As usual, coherence state for an address in
the cache denotes the permissions that the cache has for the address: $M = \{R,
W\}, S = \{R\}, I = \{\}$.

Let us assume that the caches have enough capacity so that no line gets evicted
for the sake of replacement. Lines may however get evicted to enforce the
single-writer property, \ie only one L1 cache can modify a cache line at any
time. Figure~\ref{alg:msi-easy} shows the pseudo-code for the behaviors of the
memory controller and each of the caches to implement the MSI protocol, using
the notations given in Figure~\ref{fig:notation}. 

\begin{figure}
\begin{figure}[H]
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\State Pick a request \ReqCore{c}{a}{x}{d} from core to cache $c$ \newline
$s.t.$ $state[c][a] < x$;
\ForAll {$c' \neq c,\; s.t.\; toCompatible(x) < state[c'][a]$}
  \If {$state[c'][a] = M$}
    \State $memory[a] \gets data[c'][a]$;
  \EndIf
  \State $state[c'][a] \gets toCompatible(x)$;
\EndFor
\If {$state[c][a] = I$}
  \State $data[c][a] \gets memory[a]$;
\EndIf
\State $state[c][a] \gets x$;
\end{algorithmic}
\end{boxedminipage}
\subcaption{Behavior of memory controller}
\label{alg:mem}
\end{figure}
\begin{figure}[H]
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\State Pick a request \ReqCore{c}{a}{x}{d} from core to cache $c$ \newline
$s.t.$ $state[c][a] \not< x$;
\If {$state[c][a] = M$}
  \State $update(c, a, d)$;
\ElsIf {$state[c][a] = S$}
  \State $respond(c, a, d)$;
\EndIf
\State remove \ReqCore{c}{a}{x}{d}
\end{algorithmic}
\end{boxedminipage}
\subcaption{Behavior of cache $c$}
\end{figure}
\caption{Atomic 2-level MSI protocol: memory controller has instantaneous
access to all states and data of all L1 caches and data in the memory}
\label{alg:msi-easy}
\end{figure}

\begin{figure}
\begin{minipage}{\linewidth}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$toCompatible(s)$ & If the state of one cache is $s$ for address $a$, the
highest state of another cache for the same $a$
$\newline
toCompatible(M) = I,\newline
toCompatible(S) = S,\newline
toCompatible(I) = M
$\\
\hline
$x < y$ & Does state $x$ have fewer permissions that state $y$?
$I < M, I < S, S < M$\\
\hline
$\ReqCore{c}{a}{x}{d}$ & The incoming request for cache $c$ from a core\\
\multicolumn{1}{|r}{$a$} & the address of the cache line\\
\multicolumn{1}{|r}{$x$} & the state of the cache line the request is expecting
(\ie the minimum permissions required)\\
\multicolumn{1}{|r}{$d$} & information about the word offset, the byte enables
and the data (only in the case of store)\\
\hline
$update(c, a, d)$ & Action denoting update of a cache line for address $a$ in
cache $c$ with the incoming request's information $d$\\
\hline
$respond(c, a, d)$ & Action denoting cache $c$ responding to a read request for
address $a$ with the incoming request's information $d$\\
\hline
\end{tabularx}
\subcaption{Abstraction functions}
\end{minipage}

\begin{minipage}{\linewidth}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$state[c][a]$ & coherence state (from set $\{M, S, I\}$) of cache $c$ for
address $a$\\
$data[c][a]$ & data line of cache $c$ for address $a$\\
$memory[a]$ & data line of memory for address $a$\\
\hline
\end{tabularx}
\subcaption{Values stored by a cache for an address}
\end{minipage}
\caption{Notations used in Figure~\ref{alg:msi-easy}}
\label{fig:notation}
\end{figure}

XXXXXX: End of obvious subsection
