\section{MSI protocol}
\label{sec:msi}

Let us walk through our framework using the example of a hierarchical MSI
protocol.

\floatstyle{plain}
\restylefloat{figure}

\begin{figure}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$c.state[a]$ & coherence state (from set $\{M, S, I\}$) of cache $c$ for address $a$\\
$c.data[a]$ & data in cache $c$ for address $a$\\
%$c.dir[n][a]$ & $c$'s notion of the coherence state of $n$ for address $a$\\
\hline
\end{tabularx}
\caption{Notations}
\label{table:lineinfo}
\end{figure}

\begin{figure}
\begin{subfigure}{.43\linewidth}
\centering
\begin{tabular}{|c|ccc|}
\hline
& $M$ & $S$ & $I$\\
\hline
$M$ & $=$ & $>$ & $>$\\
$S$ & $<$ & $=$ & $>$\\
$I$ & $<$ & $<$ & $=$\\
\hline
\end{tabular}
\caption{$<$ and other relations for states}
\label{msi<}
\end{subfigure}
\begin{subfigure}{.31\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$S$ & $\rightarrow$ & $S$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\caption{$toCompatible$}
\label{toCompat}
\end{subfigure}
\begin{subfigure}{.22\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $\checkmark$\\
$S$ & $\times$\\
$I$ & $\times$\\
\hline
\end{tabular}
\caption{$isModified$}
\label{isModified}
\end{subfigure}
\caption{MSI state abstraction functions}
\label{funcs}
\end{figure}

Each cache stores the information given in Figure \ref{table:lineinfo}. The
coherence state for an address denotes the (usual) permission that a cache has
for the address: $M = \{R, W\}, S = \{R\}, I = \{\}$. We can define a $<$
relation for coherence state values based on the permissions the states
represent. This is shown in Figure \ref{msi<}. State $I$ is akin to address $a$
not present in the cache.

If a cache $c$ receives a request for an address $a$ from the processor, it can
service the request straightaway if it has enough permissions for address $a$.
Otherwise, it has to \emph{upgrade} to a state $x$, which has enough
permissions. The cache can not upgrade its state arbitrarily, it has to ensure
that such a state change does not violate the single-writer property (Invariant
\label{singleWriter}), by \emph{downgrading}, \ie lowering the states of other
caches appropriately. We define a $toCompatible(x)$ mapping (Figure
~\ref{toCompat}), which specifies the highest state a cache can be, if another
cache is in state $x$ for the same address. We will also define a
$isModified(x)$ mapping to specify if an address in state $x$ in a cache can
have data different from what's present in the memory.

\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReq}{$c , p, a, x$}
  \If {$a$ is not present in $p$}
    \State Choose address $a'$ for eviction;
    \ForAll {$c' \in p.children$}
      \State \call{} \dReq($p , c', a', I$);
    \EndFor
    \State \call{} \dResp($p , p.parent, a', I$);
    \State Replace $a'$ with $a$;
    \State // $p.state[a]$ has been $I$, and remains $I$
  \EndIf
  \ForAll {$c' \in p.children, s.t., c' \neq c$}
    \State \dReq($p , c', a, toCompatible(x)$);
  \EndFor
  \State \uReqL($p , p.parent, a, x$);
  \State \uResp($p , c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Handling upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , c, a, x$}
  \ForAll {$c' \in c.children$}
    \State \dReqL($c , c', a, x$);
  \EndFor
  \State \dResp($c , p, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Handling downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dReq}
\end{subfigure}

\caption{MSI protocol}
\label{msi}
\end{figure}

\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$c , p, a, x$}
  \State \call{} \uReq($c, p, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReqL}{$p , c, a, x$}
  \State \call{} \dReq($p, c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , c, a, x$}
  \If {$c.state[a] < x$}
    \If {$c.state[a] = I$}
      \State $c.data[a] \gets p.data[a]$;
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $c$ for address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$c , p, a, x$}
  \If {$c.state[a] > x$}
    \If {$isModified(c.state[a])$}
      \State $p.data[a] \gets c.data[a]$;
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ response from $c$ to $p$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , core, a, x$}
  \State $c.data[a] \gets p.data[a]$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $core$ for address $a$}
\label{uResp}
\end{subfigure}

\caption{Atomic implementation of MSI protocol}
\label{atomic}
\end{figure}


\begin{figure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$c , p, a, x$}
  \State \send{} \Req{c}{p}{a}{x};
  \State \receive{} \Resp{p}{c}{a}{z};
  \If {$c.state[a] = I$}
    \State \receive{} \Data{p}{c}{a}{d};
    \State $c.data[a] \gets d$;
  \EndIf
  \State $c.state[a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ request from $c$ to $p$ for address $a$}
\label{uReqLocal}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReqL}{$p , c, a, x$}
  \State \send{} \Req{p}{c}{a}{x};
  \State \receive{} \Resp{c}{p}{a}{z};
  \If {$isModified(p.dir[c][a])$}
    \State \receive{} \Data{c}{p}{a}{d};
    \State $p.data[a] \gets d$;
  \EndIf
  \State $p.dir[c][a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ request from $p$ to $c$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , c, a, x$}
  \If {$p.dir[c][a] < x$}
    \If {$p.dir[c][a] = I$}
      \State \send{} \Data{p}{c}{a}{p.data[a]};
    \EndIf
    \State $p.dir[c][a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $c$ for address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$c , p, a, x$}
  \If {$c.state[a] > x$}
    \If {$isModified(c.state[a])$}
      \State \send{} \Data{c}{p}{a}{c.data[a]};
    \EndIf
    \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending downgrade to $x$ response from $c$ to $p$ for address $a$}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$p , core, a, x$}
  \State \send{} \Data{p}{c}{a}{p.data[a]};
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Sending upgrade to $x$ response from $p$ to $core$ for address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dRespL}{$c , p, a, x$}
  \If {$isModified(p.dir[c][a])$}
    \State \receive{} \Data{c}{p}{a}{d};
    \State $p.data[a] \gets d$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Handling downgrade to $x$ response from $c$ to $p$ for address $a$}
\label{uResp}
\end{subfigure}

\caption{Non atomic implementation of MSI protocol (Must also handle received
downgrade responses)}
\label{realistic}
\end{figure}

