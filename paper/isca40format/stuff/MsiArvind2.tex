\section{MSI protocol}
\label{sec:msi}

Let us walk through our framework using the example of a hierarchical MSI
protocol.

\floatstyle{plain}
\restylefloat{figure}

\begin{figure}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$c.state[a]$ & coherence state (from set $\{M, S, I\}$) of cache $c$ for address $a$\\
$c.data[a]$ & data in cache $c$ for address $a$\\
%$p.dir[n][a]$ & $p$'s notion of the coherence state of $d$ for address $a$. This is meaningful only if $p$ is not an L1 cache\\
$memory[a]$ & data in memory for address $a$\\
\hline
\end{tabularx}
\caption{Notations for information associated with an address in a cache}
\label{notation}
\end{figure}

\begin{figure}
\begin{subfigure}{.43\linewidth}
\centering
\begin{tabular}{|c|ccc|}
\hline
& $M$ & $S$ & $I$\\
\hline
$M$ & $=$ & $>$ & $>$\\
$S$ & $<$ & $=$ & $>$\\
$I$ & $<$ & $<$ & $=$\\
\hline
\end{tabular}
\caption{$<$ and other relations for states}
\label{msi<}
\end{subfigure}
\begin{subfigure}{.31\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$S$ & $\rightarrow$ & $S$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\caption{$toCompatible$}
\label{toCompat}
\end{subfigure}
\begin{subfigure}{.22\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $\checkmark$\\
$S$ & $\times$\\
$I$ & $\times$\\
\hline
\end{tabular}
\caption{$isModified$}
\label{isModified}
\end{subfigure}
\caption{MSI state abstraction functions}
\label{funcs}
\end{figure}

The caches are logically organized in the form of a tree
(Figure~\ref{fig:hierarchy}). The leaves of this tree represent the L1 caches,
with each L1 cache connected to exactly one core. The root of the tree is the
Last-Level-Cache, and its connected to the memory. The cache hierarchy is
inclusive, \ie if an address is present in a cache $c$, then it's present it its
parent $c.parent$. Note that by address we mean cache-line address, not a byte
address or a word address.

Each cache stores the coherence state and the data for each address that it
contains.
%A cache which is not L1 (\ie an internal node in the tree of caches)
%also stores a directory containing its notion of the coherence states of its
%children.
Figure \ref{notation} gives the notation used to represent all this
information. For an L1 cache, the coherence state for an address denotes the
(usual) permission that a core connected to the L1 cache has for the address: $M
= \{R, W\}, S = \{R\}, I = \{\}$. We can define a $<$ relation for coherence
state values based on the permissions the states represent. This is shown in
Figure \ref{msi<}.
%When an address $a$ not present in the L1 cache, then the
%core associated with that L1 can neither read nor write that address, so it's
%equivalent to the state of that address being $I$.

For a non L1 cache, the meaning of coherence states is different. For an
internal node $n$, if $n.state[a] = I$, then, the entire sub-tree rooted at $n$
will have coherence state $I$ for address $a$. In particular, no L1 cache in
this subtree will have any permission for $a$. If $n.state[a] = S$, then its
children can either be in $S$ or $I$ state. Finally, if $n.state[a] = M$, then
at most one of its children can be in $M$ state. This guarantees that at most
one of the L1 caches can have write permissions, ensuring the following
invariant:

\begin{inv}
\textbf{Single-writer Invariant}: When a cache has permission to modify data for
an address, no other cache has read or write permission for that
address.
\label{singleWriter}
\end{inv}

We define a $toCompatible(x)$ mapping (Figure ~\ref{toCompat}), which specifies
the highest state a cache can be to not violate the Single-writer Invariant, if
another sibling cache is in state $x$ for the same address.

The coherence states also denote the consistency of data in a cache with respect
to its parent. If a cache (both L1 and non-L1) is in state $I$ for an address $a$,
then it does not have the data corresponding to that address. If it is in state
$S$, then its data is consistent with that of its parent. Finally, if it is in
state $M$, then its data is not consistent with that of its parent. If none of
its children are in state $M$, then the data in this cache is the most
up-to-date value. But if one of its children $c$ is in the $M$ state, then the
data in this cache is stale -- the most up-to-date value is present in the
subtree rooted at $c$.

We define a $isModified(x)$ mapping to specify if an address in state $x$ in a
cache can have data different from what's present in its parent. The mappings
$toCompatible$ and $isModified$ abstract away the semantics of the states so
that our framework can be extended to other protocols like MOSI/MOESI.

If a cache having no permission for an address requires read or write
permissions for that address, then the most up-to-date value must be supplied,
\ie:

\begin{inv}
\textbf{Read-from-last-writer}: When a cache reads data for an address, it reads
the last modified version of the data for the address. If the data for an
address has not been modified, the cache reads the data from memory.
\label{lastRead}
\end{inv}

Invariants \ref{singleWriter} and \ref{lastRead} together ensure cache coherence
\cite{Patterson}.

We will first describe an atomic version of the hierarchical MSI protocol. In
the atomic protocol, when a core connected to an L1 cache initiates an upgrade
for an address, no other core can initiate an upgrade for any address till the
former L1 cache has finished upgrading. This can be implemented in hardware
using a bus-based system, which locks the bus till an initiated upgrade has
completed.

\floatstyle{boxed}
\restylefloat{figure}

\begin{figure}
\small

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\textsc{processReq}}{$c, a, op, data$}
  \If {$op = Ld$}
    \State \textbf{if} ($c.state[a] \ge S$)
    \State \;\;\;\; \call{} $c.$\uReq($this, a, S$);
    \State \textbf{return} $c.data[a]$;
  \ElsIf {$op = St$}
    \State \textbf{if} ($c.state[a] = M$)
    \State \;\;\;\; \call{} $c.$\uReq($this, a, M$);
    \State $update(c.data[a], data)$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{core handling a load or a store request by calling the request
handler in its L1 cache}
\label{coreHandle}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReq}{$c , a, x$}
    \If {$a$ is not present in $this$}
      \If {$this$ has no space for $a$}
        \State Choose address $a'$ for eviction;
        \State \textbf{forall} ($c' \in this.children$)
        \State \;\;\;\; \textbf{if} ($c'.state[a'] > I$)
        \State \;\;\;\;\;\;\;\; \call{} $c'.$\dReq($this, a', I$);
        \If {$this.state[a'] > I$}
          \State \textbf{if} ($this.state[a'] = M$)
          \State \;\;\;\; $(this.parent).data[a'] \gets this.data[a']$;
          \State $this.state[a'] \gets I$;
        \EndIf
      \EndIf
      \State Allocate a line for $a$;
    \EndIf
    \State // $a$ is already present in $this$
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} ($c'.state[a] > toCompatible(x)$)
    \State \;\;\;\;\;\;\;\; \call{} $c'.$\dReq($this, a', toCompatible(x)$);
    \State \textbf{if} ($this$ is Last-Level-Cache \&\& $this.state[a] = I$) \bopen
    \State \;\;\;\; $this.data[a] \gets memory[a]$;
    \State \;\;\;\; $this.state[a] \gets M$;
    \State \bclose \;\textbf{else}
    \State \;\;\;\; \call{} $(this.parent.)$\uReq{}($this, a, x$);
  \If {$c \neq core$}
  \State \textbf{if} ($c.state[a] = I$)
  \State \;\;\;\; $c.data[a] \gets this.data[a]$;
  \State $c.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's upgrade request handler -- request from one of $this$' children, $c$, to upgrade $c$'s state to $x$ for address $a$ }
\label{atomicUReq1}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , a, x$}
  \If {$this.state[a] > x$}
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} (c'.state[a] > x)
    \State \;\;\;\;\;\;\;\; \call{} $c'.$\dReq($this, a, x$);
    \State \textbf{if} ($this.state[a] = M$)
    \State \;\;\;\; $p.data[a] \gets this.data[a]$;
    \State $this.state[a] \gets x$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's downgrade request handler -- request from $this$' parent, $p$, to upgrade $this$' state to $x$ for address $a$ }
\label{atomicDReq1}
\end{subfigure}

\caption{Atomic MSI protocol}
\label{msi-simple}
\end{figure}

Figure \ref{msi-simple} gives the pseudo-code for handling a request from a
core. The caches and the cores can be thought of as objects with methods. The
core has a \textsc{processReq} method which it invokes to process a load or
store request. The core first checks if its L1 cache has the required state. If
not, it invokes the L1 cache's upgrade request handler \uReq{}. \uReq{} in turn
calls the upgrade request handler of which would upgrade the state of the
L1-cache, and finally the request from the core will be serviced. Note that the
core supplies words or long-words while the cache line sizes are typically 64
bytes; only the appropriate word in the cache line is updated in case of a
store.

In the case of a non-L1 cache, $this$, when its upgrade request handler is
invoked by its child $c$, if the requested addres is not already in $this$, it
tries to get a line for the address. If the cache has no empty slots for the
requested address, an existing address is evicted. In order to evict an address
$a'$, to maintain the inclusiveness property, the address $a'$ has to be evicted
in all of the $this$' children. This is done by calling the downgrade request
handler \dReq{} of each of its child which is at a higher state than $I$ for
that address; such a child is asked to downgrade to $I$ state. Once the children
have evicted, if data in $this$ is modified with respect to its parent, then the
data is written back. At this point a line is allocated for the originally
requested address.

Once $this$ has established that it has a line for the requested address, it now
has to ensure that the states of its other children are compatible with the
requested upgrade; $this$ again invokes its children's downgrade request handler
\dReq{}, for all the children who are at a higher state than what is compatible,
to downgrade them to the compatible state. $this$ invokes its parents upgrade
request handler ($(this.parent).\uReq{}$), which in turn will will do the same
sequence of operations and eventually upgrade $this$' state. Finally, $this$
upgrades the state of the requesting child $c$, and sends data to $c$ if
necessary.

When a cache, $this$', downgrade handler is invoked by its parent, it in turn
invokes the downgrade handler of all its children which are at a higher state
than what the parent requested. Once all the children have downgraded their
respective states, $this$ downgrades its own state and writes the data back to
its parent if it has been modified with respect to the parent, \ie if $this$ is
in $M$ state.

In the case of an L1 cache, once the cache's parent has upgraded its state,
there is no child to upgrade to. Similarly, in the case of a Last-Level-Cache,
the cache simply reads data from the memory if the line is not present in the
cache, since it has no parent whose upgrade request handler it can invoke. All
lines in the Last-Level-Cache are made to be in $M$ state.

\subsection{Refactoring the handler methods}
\begin{figure}
\small

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReq}{$c , a, x$}
    \If {$a$ is not present in $this$}
      \If {$this$ has no space for $a$}
        \State Choose address $a'$ for eviction;
        \State \textbf{forall} ($c' \in this.children$)
        \State \;\;\;\; \textbf{if} ($c'.state[a] > I$)
        \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a', I$);
        \State \textbf{if} ($this.state[a'] > I$)
        \State \;\;\;\; \call{} $this.$\dResp{}($this.parent, a', I$);
      \EndIf
      \State Allocate a line for $a$;
    \EndIf
    \State // $a$ is already present in $this$
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} ($c'.state[a] > toCompatible(x)$)
    \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a', toCompatible(x)$);
    \State \textbf{if} ($this$ is Last-Level-Cache \&\& $this.state[a] = I$)
    \State \;\;\;\; \call{} $this$.\sendMem{}($a$);
    \State \textbf{else}
    \State \;\;\;\; \call{} $this.$\uReqL{}($this.parent, a, x$);
  \State \textbf{if} ($c \neq core$)
  \State \;\;\;\; \call{} $this$.\uResp{}($c, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's upgrade request handler -- request from one of $this$' children, $c$, to upgrade $c$'s state to $x$ for address $a$ }
\label{atomicUReq1}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReq}{$p , a, x$}
  \If {$this.state[a] > x$}
    \State \textbf{forall} ($c' \in this.children$)
    \State \;\;\;\; \textbf{if} (c'.state[a] > x)
    \State \;\;\;\;\;\;\;\; \call{} $this.$\dReqL($c', a, x$);
    \State \call{} $this.$\dResp($p, a, x$);
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ cache's downgrade request handler -- request from $this$'
parent, $p$, to upgrade $p$'s state to $x$ for address $a$ }
\label{atomicDReq1}
\end{subfigure}

\caption{MSI protocol -- general template}
\label{msi-template}
\end{figure}

\begin{figure}
\small

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$p, a, x$}
  \State \call{} $p.$\uReq($this, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Upgrading address $a$ of $this$ to $x$, by invoking the upgrade handler
of $this$'s parent, $p$}
\label{uReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReqL}{$c , a, x$}
  \State \call{} $c.$\dReq($this, a, x$);
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Downgrading address $a$ of $this$'s child $c$ to $x$, by invoking
$c$'s downgrade handler}
\label{dReq}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$c, a, x$}
  \If {$c.state[a] = I$}
    \State $c.data[a] \gets this.data[a]$;
  \EndIf
  \State $c.state[a] \gets x$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ finally upgrading address $a$ of its child $c$ to $x$, and
updating the data of $c$ if necessary}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$p, a, x$}
  \If {$isModified(c.state[a])$}
    \State $p.data[a] \gets this.data[a]$;
  \EndIf
  \State $this.state[a] \gets x$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ finally downgrading its state for address $a$ to $x$ and
updating data of its parent $p$ if necessary}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\sendMem{}}{$a$}
  \State $this.data[a] \gets memory[a]$;
  \State $this.state[a] \gets M$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Last-Level-Cache $this$ reading data from memory for address $a$}
\label{uResp}
\end{subfigure}

\caption{Atomic implementation of MSI protocol}
\label{atomic}
\end{figure}

Figure \ref{msi-template} shows how the request handler methods \uReq{} and
\dReq{} can be refactored to make it amenable to distributed implementation. The
upgrade and downgrade request handlers are not allowed to invoke other cache's
upgrade or downgrade request handlers, or change other cache's states. Instead,
the same calls are made via 5 more local methods listed in Figure \ref{atomic}.
These methods in turn invoke the other caches upgrade and downgrade request
handlers, or change the states of other caches.

\begin{figure}
\small

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uReqL}{$p, a, x$}
  \State \send{} \Req{this}{p}{a}{x};
  \State \receive{} \Resp{p}{this}{a}{z};
  \If {$this.state[a] = I$}
    \State \receive{} \Data{p}{this}{a}{d};
    \State $this.data[a] \gets d$;
  \EndIf
  \State $this.state[a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Upgrading address $a$ of $this$ to $x$, by sending a request to
$this$'s parent $p$}
\label{uReqLocal}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dReqL}{$c, a, x$}
  \State \send{} \Req{this}{c}{a}{x};
  \State \receive{} \Resp{c}{this}{a}{z};
  \If {$isModified(this.dir[c][a])$}
    \State \receive{} \Data{c}{this}{a}{d};
    \State $this.data[a] \gets d$;
  \EndIf
  \State $this.dir[c][a] \gets z$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Downgrading address $a$ of $this$'s child $c$ to $x$, by sending a
request to $c$}
\label{dReqLocal}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\uResp}{$c, a, x$}
  \State \textbf{if} ($this.dir[c][a] = I$)
  \State \;\;\;\; \send{} \Data{this}{c}{a}{this.data[a]};
  \State $this.dir[c][a] \gets x$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ finally upgrading address $a$ of its child $c$ to $x$, sending a
response to $c$ notifying of the upgrade and sending data to $c$ if necessary}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dResp}{$p, a, x$}
  \State \textbf{if} ($isModified(this.state[a])$)
  \State \;\;\;\; \send{} \Data{this}{p}{a}{this.data[a]};
  \State $this.state[a] \gets x$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ finally downgrading its state for address $a$ to $x$, sending a
response to $c$ notifying of the downgrade and sending data to $c$ if necessary}
\label{dResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\dRespL}{$c , a, x$}
  \If {$isModified(this.dir[c][a])$}
    \State \receive{} \Data{c}{this}{a}{d};
    \State $this.data[a] \gets d$;
  \EndIf
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{$this$ handling unsolicited downgrade to $x$ response from $c$ for
address $a$. This happens if $c$ evicted address $a$}
\label{uResp}
\end{subfigure}

\begin{subfigure}{\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{algorithmic}
\Proc {\sendMem{}}{$a$}
  \State \send{} \Req{this}{Memory}{a}{M};
  \State \receive{} \Data{Memory}{this}{a}{d};
  \State $this.data[a] \gets d$;
  \State $this.state[a] \gets M$;
\EndProc
\end{algorithmic}
\end{boxedminipage}
\caption{Last-Level-Cache $this$ sending and receivging data from memory for
address $a$}
\label{uResp}
\end{subfigure}

\caption{Non atomic implementation of MSI protocol}
\label{realistic}
\end{figure}

