\section{A two-level message-passing directory-based MSI protocol}
\label{sec:msi}

\newcommand{\fourAngle}[6]{\text{$#1\langle#2\rightarrow#3,#4,#5\rightarrow#6\rangle$}}
\newcommand{\threeAngle}[5]{\text{$#1\langle#2\rightarrow#3,#4,#5\rangle$}}

%\newcommand{\Req}[5]{\fourAngle{Req}{#1}{#2}{#3}{#4}{#5}}
\newcommand{\Req}[4]{\threeAngle{Req}{#1}{#2}{#3}{#4}}
\newcommand{\Resp}[4]{\threeAngle{Resp}{#1}{#2}{#3}{#4}}

\newcommand{\msg}[5]{\text{$#1 \langle #2 \rightarrow #3, #4, #5 \rangle$}}
%\newcommand{\Req}[5]{\msg{Req}{#1}{#2}{#3}{#4}{#5}}
%\newcommand{\Resp}[5]{\msg{Resp}{#1}{#2}{#3}{#4}{#5}}
%\newcommand{\Data}[4]{\msg{Data}{#1}{#2}{#3}{#4}}
%\newcommand{\Mesg}[4]{\msg{Mesg}{#1}{#2}{#3}{#4}}
%\input{Atomic}

Let us walk through our framework using the example of an MSI protocol.  We will
start with a simple system for the sake of explanation.  The system has two
levels of memory hierarchy -- private L1 caches for each core and a shared
memory. The L1 caches do not have direct access to the memory, and the memory
does not have a direct access to the actual states in the  L1 caches, or L1's
data. Instead, the main memory has direct access to a directory associated with
it which keeps a version of the L1 cache states for each address. The L1 caches
do not have direct access to this directory. The directory's version of the L1
cache states may differ from the actual L1 cache states. We use the terms memory
and directory interchangeably.

\begin{figure}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$state[c][a]$ & coherence state (from set $\{M, S, I\}$) of cache $c$ for address $a$\\
$data[c][a]$ & data in cache $c$ for address $a$\\
\hline \end{tabularx}
\caption{Values stored by an L1 cache $c$ for an address $a$}
\label{table:lineinfo}
\end{figure}

\begin{wrapfigure}{r}{.4\linewidth}
\centering
\begin{tabular}{|c|ccc|}
\hline
& $M$ & $S$ & $I$\\
\hline
$M$ & $=$ & $>$ & $>$\\
$S$ & $<$ & $=$ & $>$\\
$I$ & $<$ & $<$ & $=$\\
\hline
\end{tabular}
\caption{$<$ and other relations for MSI states}
\label{msi<}
\end{wrapfigure}

Each L1 cache stores the information given in Figure \ref{table:lineinfo}. The
coherence state for an address denotes the permission that a cache has for the
address: $M = \{R, W\}, S = \{R\}, I = \{\}$. We can define a $<$ relation for
coherence state values based on the permissions the states represent. This is
shown in Figure \ref{msi<}. State $I$ is akin to the cache not having the data
corresponding to $a$, since it can neither read or write the $a$'s data. Figure
\ref{table:dirinfo} shows the information stored in the memory and directory. 

\begin{figure}
\begin{tabularx}{\linewidth}{|cX|}
\hline
$dir[c][a]$ & directory's version of the coherence state of cache $c$ for address $a$\\
$memory[a]$ & data in the memory address $a$\\
\hline
\end{tabularx}
\caption{Values stored by a directory and memory for an address}
\label{table:dirinfo}
\end{figure}

The L1 caches and the directory communicate with each using via messages. Each
L1 cache communicates with its core via 2 buffers -- incoming for requests and
outgoing for responses. Each L1 cache communicates with the memory directly via
4 buffers -- two incoming buffers from the memory, one each for requests and
responses from the memory, and two outgoing buffers into the memory, one each
for requests and responses to the memory. All these buffers converge into or
diverge from 4 buffers of the memory -- two incoming buffers, one each for
requests and responses from the caches and two outgoing buffers, one each for
requests and responses to the caches (Figure \ref{fig:setup}). All these
buffers have the FIFO property. Not only that, we will also assume that requests
sent from a source will never reach its destination till an earlier response
sent by the same source has been serviced (and hence removed) by the destination.
%We will show in Section \ref{sec:fifo} about how these network requirements can
%be realistically implemented.

\subsection{No evictions due to replacement}
\label{sec:msi-magic}

We will first design an MSI protocol in which the L1 caches have enough
capacity (or rather associativity) so that no line gets evicted due to
replacement. Lines may however get evicted to enforce the following invariant
which is needed for maintaining cache coherence.

%\begin{inv}
\textbf{Single-writer Invariant}: When a cache has permission to modify data for
an address ($M$ state), no other cache has read or write permission for that
address. In other words, the other caches must be in $I$ state.
\label{singleWriter}
%\end{inv}

\begin{wrapfigure}{r}{.46\linewidth}
\begin{subfigure}{.27\linewidth}
\centering
\begin{tabular}{|ccc|}
\hline
$M$ & $\rightarrow$ & $I$\\
$S$ & $\rightarrow$ & $S$\\
$I$ & $\rightarrow$ & $I$\\
\hline
\end{tabular}
\caption*{$toCompatible$}
\label{toCompat}
\end{subfigure}
~~~~~~~~~~~~~~
\begin{subfigure}{.21\linewidth}
\centering
\begin{tabular}{|c|c|}
\hline
$M$ & $\checkmark$\\
$S$ & $\times$\\
$I$ & $\times$\\
\hline
\end{tabular}
\caption*{$isModified$}
\label{isModified}
\end{subfigure}
\caption{$toCompatible$ and $isModified$ mappings}
\label{fig:msimap}
\end{wrapfigure}

Because of the Single-writer invariant, it makes sense to talk about
compatibility of the states of two caches for an address. Two cache states $x$
and $Y$ are \emph{compatible} if two caches having the same address in states
$x$ and $y$ do not violate the Single-writer invariant. We define a mapping
$toCompatible(x)$ which gives the highest state which is compatible with a given
state $x$ (Figure \ref{fig:msimap}).

In addition to Single-writer Invariant, maintaining cache coherence also
requires the following invariant:

%\begin{inv}
\textbf{Read-from-last-writer}: When a cache reads data for an address, it reads
the last modified version of the data for the address. If the data for an
address has not been modified, the cache reads the data from memory.
%\end{inv}

Function $isModified(x)$ determines if data for an address state $x$ can
potentially be modified or not (Figure \ref{fig:msimap}).

If a cache $c$ receives a request for an address $a$ from the processor, it can
service the request straightaway if it has enough permissions for address $a$.
Otherwise, it has to get to a state for $a$, say $y$, which has enough
permissions. In other words, it has to \emph{upgrade} its state to $y$. In order
to maintain the Single-writer Invariant, cache $c$ has to
ensure that the states of other caches are \emph{compatible} with $y$. But the
caveat is that $c$ can access only its own state and data, as opposed to that of
other caches (or the directory).

Cache $c$ has to instead communicate with the directory to ensure that the
states of other caches are compatible. $c$ must send a message
\Req{c}{Dir}{a}{y} requesting the directory to tell if it can upgrade its state
for address $a$ to $y$. We call this an \emph{upgrade request}. Let us now take
for granted that such a message can be sent (Invariant \ref{csendreq} in Figure
\ref{DirInv}).

We will also assume that that a cache can upgrade its state to $y$ only after
receiving and servicing a message from the directory \Resp{Dir}{c}{a}{y}
permitting it to upgrade its state for address $a$ to $y$ (Invariant
\ref{cwaitresp} in Figure \ref{DirInv}). We call such a message as an
\emph{upgrade response}.

We introduce two other kinds of messages: \emph{downgrade request}
\Req{Dir}{c'}{a}{y} sent from the directory to a cache $c'$ asking $c'$ to
downgrade its state for address $a$ to $y$, and \emph{downgrade response}
\Resp{c'}{Dir}{a}{y} sent from $c'$ to the directory informing the directory
that $c'$ has changed its state $state[c'][a]$ from $x$ to $y$, where $x > y$.

How can the behavior of the directory be designed (in terms of sending and
receiving messages) to ensure that cache $c$ will get an upgrade response
eventually. Let's say the invariants given of Figure \ref{DirInv} are
somehow guaranteed (we have already assumed that invariants \ref{csendreq} and
\ref{cwaitresp} are guaranteed). With these invariants, let us design the
behavior of the directory.

\floatstyle{boxed}
\restylefloat{figure}
\begin{figure}
\begin{inv}
A cache will eventually be able to send an upgrade request.
\label{csendreq}
\end{inv}
\begin{inv}
Cache $c$ can upgrade $state[c][a]$ from $x$ to $y$ where $y > x$ only after it
receives and services an upgrade response \Resp{Dir}{c}{a}{y} from the directory.
\label{cwaitresp}
\end{inv}
\begin{inv}
Just before starting to service an upgrade request \Req{c}{Dir}{a}{y} from $c$,
$dir[c][a] < y$.
\label{drecvreq}
\end{inv}
\begin{inv}
The directory will eventually be able to send any downgrade request to any cache
$c$.
\label{dsendreq}
\end{inv}
\begin{inv}
The directory can change $dir[c][a]$ from $x$ to $y$ where $y < x$, \ie
downgrade its directory state only after receiving and servicing a downgrade
response \Resp{c}{Dir}{a}{y} from $c$.
\label{dwaitresp}
\end{inv}
\begin{inv}
If the directory has sent a downgrade request \Req{Dir}{c}{a}{y} to cache $c$,
it will eventually get a downgrade response \Resp{Dir}{c}{a}{z} from cache $c$
such that $z \le y$.
\label{drecvresp}
\end{inv}
\begin{inv}
When a cache $c$ sends a downgrade response \Resp{c}{Dir}{a}{y} to the
directory and $state[c][a] = x$ just before sending the downgrade response, then
$dir[c][a] = x$ from the time the response was sent by $c$ to the time the
directory services the response.
\label{cknows}
\end{inv}
\begin{inv}
When a directory sends an upgrade response \Resp{Dir}{c}{a}{y} to cache $c$ and
$dir[c][a] = x$ just before sending the downgrade response, then $cache[c][a] = x$
from the time the response was sent by the directory to the time the $c$
services the response.
\label{dknows}
\end{inv}
%\begin{inv}
%Just before receiving a downgrade response from $c$, if $isModified(dir[c][a])$
%is true, then $c$ would have sent the data along with the downgrade response.
%\label{drecvdata}
%\end{inv}
\begin{inv}
The directory will eventually be able to send any upgrade response to any cache
$c$.%It can also send the data to cache $c$ along with the upgrade response.
\label{dsendresp}
\end{inv}
\begin{inv}
Conservative directory:
\begin{spacing}{.1}
\begin{equation*}
\forall c, a,\; dir[c][a] \ge state[c][a]
\end{equation*}
\end{spacing}
\label{conservative}
\end{inv}
\caption{Directory invariants}
\label{DirInv}
\end{figure}
\floatstyle{plain}
\restylefloat{figure}

%The directory ensures that the states of any two caches for an address are
%compatible by the following behavior.
%When the directory receives an upgrade request
%\Req{c}{Dir}{a}{x}, Invariant \ref{drecvreq} guarantees that $dir[c][a] < x$ and
%because of Invariant \ref{conservative}, $cache[c][a] le dir[c][a]$, resulting
%in $cache[c][a] < x$. Unless the directory sends an upgrade response to $c$
%permitting it to upgrade to $x$, $c$ will remain in state $cache[c][a]$ forever
On receiving an upgrade request \Req{c}{Dir}{a}{x}, the directory sends a
downgrade request \Req{Dir}{c'}{a}{toCompatible(x)} to every cache $c'$
for which $dir[c'][a] > toCompatible(x)$. Such a request can be sent eventually
because of Invariant \ref{dsendreq}. The incoming upgrade request is not
removed and no further upgrades requests are processed till an appropriate
upgrade response is sent back from the directory to $c$.

Because of Invariant \ref{drecvresp}, the directory will eventually receive
downgrade responses \Resp{c'}{Dir}{a}{z} from each of the requested caches $c'$
such that $z \le toCompatible(x)$ (since the directory made a downgrade request
to go to $toCompatible(x)$). Just before servicing the downgrade response, if
$isModified(dir[c'][a])$ is true (\ie $dir[c'][a] = M$), the directory be
 waits for data to be sent by $c'$. $c'$ knows that the directory's
version of its state for address $a$, at the time \Resp{c'}{Dir}{a}{z} is
serviced by the directory will be the same as the state of $c'$ right before it
sends the downgrade response (by Invariant \ref{cknows}), and hence would know
if the directory is expecting data by simply checking for
$isModified(state[c'][a]$ at the time of sending the downgrade response. So $c'$
can be implemented to send the data along with the response if required. If the
directory receives data, the memory for address $a$ is updated with the received
data.

Once all the downgrade responses have been received and serviced, since no
upgrade responses have been sent to any cache in the meanwhile, we have $\forall
c' \neq c, dir[c'][a] \le toCompatible(x)$. Because of Invariant
\ref{conservative}, it is guaranteed that $\forall c' \neq, cache[c'][a] \le
toCompatible(x)$. The directory now changes $dir[c][a]$ to $x$ and sends an
upgrade response \Resp{Dir}{c}{a}{x} to $c$. If $dir[c][a] = I$ right before
changing it to $x$, then by Invariant \ref{dknows}, $cache[c][a]$ is going to be
$I$ till cache $c$ services the upgrade response. So, in this case, the data
from the memory for address $a$ is also sent along with the upgrade response.
Note that such an upgrade response, can always be sent eventually by the
directory because of Invariant \ref{dsendresp}. Finally, the upgrade response
from $c$ has been serviced and hence removed by the directory.

The above behavior for the directory ensures that the states of any two caches
for every address are compatible, thus obeying Single-writer Invariant. This can
be proven by noting that whenever an upgrade to $x$ request from $c$ is being
serviced, every other cache is ensured to be in a state $\le toCompatible(x)$
before an upgrade response is eventually sent to $c$. Similarly, it can be
easily shown to obey Read-from-last-writer Invariant.

%The above behavior for the directory ensures that the states of any two caches
%for every address are compatible, as can seen by induction.  This property is
%true initially because every cache is in state $I$ for every address. If this
%property is true before the servicing of a request is started, it will be true by the
%time the request is serviced and an upgrade response is sent. This is because an
%upgrade response is sent only when every cache other than the one requesting is
%at a state $\le toCompatible(x)$, where $x$ is the state the requesting cache
%wants to go to, and $toCompatible(x)$ is the highest state that a cache can be
%in to be compatible with another cache in state $x$ for an address.

%Whenever the directory receives a downgrade response from a cache $c'$, just
%before servicing the response if $isModified(dir[c'][a])$ is true, \ie
%$dir[c'][a] = M$, $c'$ must have been the only cache with permission to modify
%address $a$. This is because the directory ensures that the states of any two
%caches for address $a$ is compatible at all times (as shown above). Thus, to
%ensure the Read-from-last-writer Invariant, the potentially modified data from
%$c'$ is written back from into the memory on receiving the downgrade response
%from $c'$ as seen in our design.

The invariants \ref{drecvreq} to \ref{conservative} in Figure \ref{DirInv}
essentially makes it straight forward to design the behavior of the directory.
Without these invariants, it will be hard to reason about the correctness of the
protocol as shown by the following examples.

For the sake of argument, let us assume Invariant \ref{drecvreq} not be
guaranteed. Consider a scenario in which the cache $c$ which has sent a request
\Req{c}{Dir}{a}{M}. Before servicing an upgrade response for this request, $c$
sends another upgrade request \Req{c}{Dir}{a}{S}. Once the directory has
finished processing the first request, it changes its directory state
$dir[c][a]$ to $M$. When it starts servicing the second request, it is not easy
to decide if the directory has to drop the request or to send an upgrade to $S$
response.

As another example, let us assume that Invariant \ref{dknows} does not hold.
Let's say the $dir[c][a] = S$ right before the directory sends an upgrade
response \Resp{Dir}{c}{a}{M} to cache $c$. The directory will not send the data
because in its version of the state of $c$ for address $a$, cache $c$ already
has the data. But if the directory was wrong, and at the time cache $c$ services
the upgrade response, if $state[c][a]$ is $I$, then cache $c$ will no longer
have the right data, breaking the Read-from-last-writer Invariant.

The difficulty in message passing protocols comes from the fact that it is
difficult to guarantee the above invariants, even for a 2-level memory hierarchy
discussed above. as shown in the following scenarios.

%These scenarios show that if the invariants of Figure \ref{DirInv} are violated,
%then it either breaks cache coherence (by creating deadlocks) or it makes
%it hard to reason about the behavior of the directory.

%\begin{scen}
%\emph{Inability to send messages because of network congestion:}
%The ability of a cache or the directory to send messages (Invariants
%\ref{dsendreq}, \ref{dsendresp} and \ref{csendreq}) depends upon the
%availability of free buffers in the network; if the network remains congested
%all the time, then it would not be possible to send the messages, and the system
%would deadlock.
%\end{scen}
%
%\begin{scen}
%\emph{Multiple upgrade requests from the cache for the same address:}
%If a cache is allowed to make multiple requests to upgrade the state of an
%address (say to $M$ and then to $S$) before receiving the upgrade responses,
%then it might violate Invariant \ref{drecvreq} if the requests were processed by
%the directory in the order they were received. This makes the decision on
%whether the directory drops the second request or not hard to reason about, as
%shown above.
%\end{scen}

\begin{scen}
\emph{On sending an upgrade request, the cache stops processing downgrade
requests it gets an upgrade response:}
Consider a scenario with two caches $c$ and $c'$, with both the caches in state
$S$ for address $a$. Both the caches get a store request from the processor and
send \Req{c}{Dir}{a}{M} and \Req{c'}{Dir}{a}{M}, respectively, to the directory.
Let's say \Req{c'}{Dir}{a}{M} arrives at the directory first. The directory
sends a downgrade request to cache $c$, but since $c$ does not process any
downgrade requests till it gets its upgrade response, it will never send back a
downgrade response to the directory, violating Invariant \ref{drecvresp},
resulting in a deadlock. Note that this deadlock would occur even if a cache
waiting for an upgrade response for an address, stops processing downgrade
requests for other addresses.
\label{noprocess}
\end{scen}

\begin{scen}
\emph{At the directory, downgrade responses from caches are blocked by upgrade
requests:}
Consider a scenario where two caches $c$ and $c'$ are both in state $S$ for
address $a$. $c'$ gets a store request from the processor and sends an upgrade
request \Req{c'}{Dir}{a}{M} to the directory. The directory receives that
request, and sends a downgrade request \Req{c}{Dir}{a}{I} to $c$. $c$ sends a
downgrade response \Resp{c}{Dir}{a}{I} to the directory on receiving the
downgrade request. But the directory can not service the downgrade response because
it is blocked by other requests (including \Req{c'}{Dir}{a}{M}). This violates
Invariant \ref{drecvresp} and hence creates a deadlock.
\label{scen:block}
\end{scen}

Let us consider a slightly more complicated system where caches can evict lines
for replacement before proceeding further.

\subsection{Evictions due to replacement are allowed}
If a cache starts servicing a request from the core for an address $a$ and has
no space to accommodate address $a$, it evicts another address $a'$ to make room
for $a$.

In the previous scenario, the caches didn't have to evict for replacement; a
cache had to send downgrade responses to the directory only on servicing a
corresponding request. But in the new scenario, a cache can send a downgrade
notification voluntarily to the directory on evicting an address. The directory
has to process this new notification: on servicing the downgrade to $y$
notification for an address $a$ from cache $c$, the directory changes
$dir[c][a]$ to $y$, keeping the directory's version of the cache's state
up-to-date. Since the directory can not distinguish between the downgrade
notification sent voluntarily and a downgrade response sent because of a
downgrade request from the directory, we will use the same message to denote
both.

%We will restrict the family of directory-based protocols that that
%we discuss to those in which the caches send such notifications.

We will first discuss an example of the behavior of the L1 cache that would
violate Invariant \ref{conservative}, if the cache is allowed to voluntarily
send a downgrade response due to eviction.

\begin{scen}
\emph{Cache sends voluntary downgrade responses indiscriminately:}
Consider a system with only two caches $c$ and $c'$ (Figure \ref{fig:cross})
such that $state[c][a] = dir[c][a] = S$, and $state[c'][a] = dir[c'][a] = I$.
Let $c$ be a non-blocking cache, so it can process requests from the core even
if there are pending misses. $c$ receives a store request for address $a$ from
the core and sends \Req{c}{Dir}{a}{M} to the directory. Before it gets back an
upgrade response from the directory, it receives another load request for
address $a'$ from the core. Suppose the line for $a'$ is not present in $c$ and
$c$ has no space for $a'$, it decides to evict address $a$ to make room for
$a'$. It voluntarily sends a downgrade response \Resp{c}{Dir}{a}{I} to the
directory. Meanwhile, the directory receives the upgrade request
\Req{c}{Dir}{a}{M}, and since the directory state of the only other cache is $I$
for address $a$, the directory sends back an upgrade response. The directory
then receives the downgrade response \Resp{c}{Dir}{a}{I} and changes $dir[c][a]$
to $I$. $c$ finally receives the upgrade response \Resp{Dir}{c}{a}{M} and
upgrades $state[c][a]$ to $M$. This breaks Invariant \ref{conservative}, since
$state[c][a] = M$ and $dir[c][a] = I$. If the directory gets an upgrade to $M$
request for address $a$ from $c'$, it will assume that $c$ is in state $I$ for
address $a$ and send an upgrade to $M$ response to $c'$. This will violate the
Single-writer invariant, thereby violating coherence.
\label{indisc}
\end{scen}

\subsection{Meta-rules that guarantee the invariants of Figure \ref{DirInv}}

We now show meta-rules for implementation of a message-passing directory-based
protocol in order to guarantee the invariants of Figure \ref{DirInv}; this has
been formally proven using the Coq theorem prover. We will present some
intuition behind the proof by showing how these constraints avoid scenarios
\ref{noprocess}, \ref{scen:block} and \ref{indisc}, though the formal proof is
beyond the scope of the paper. These meta-rules are amenable to direct
implementation because each of the meta-rules access only local states.

%We will present the intuition behind the proof by showing how
%these constraints avoid scenarios \ref{noprocess}, \ref{scen:block} and
%\ref{indisc}, though the formal proof is beyond the scope of the paper.

\floatstyle{boxed}
\restylefloat{figure}
\begin{figure}
\begin{cons}
Requests for an address $a$ should not block responses for address $a$, even
from a different source.
\end{cons}
\caption{Meta-rules for blocking}
\label{block}
\end{figure}
\begin{figure}
\begin{cons}
Responses to the directory for the same address $a$ from the same cache $c$
should be serviced by the directory in the order they were sent.
\end{cons}
\begin{cons}
Requests for an address $a$ from a source $n$ (cache or directory) should not be
serviced by a destination $m$ (directory or cache) before $m$ has serviced all the
responses for the same address $a$ from the same source $n$ sent earlier. In
other words, requests between caches and directory should not overtake responses
between caches and directory if they are sent from the same source to the same
destination for the same address.
\end{cons}
\caption{Meta-rules for ordering}
\label{order}
\end{figure}

Figures \ref{block} and \ref{order} gives the meta-rules about which messages
should not block each other, and the ordering requirements between messages. The
setup in Figure \ref{fig:setup} and the stated FIFO requirements guarantees
these meta-Rules. We will show how these meta-rules can be realistically
realized in Section \ref{sec:fifo}.

\begin{figure}
\begin{cons}
A response for address $a$ can be sent by a cache to the directory or by the
directory to the cache only if the line for $a$ is present in the sending node.
\end{cons}
\begin{cons}
A response from the directory to cache $c$ for address $a$ can be sent only if a
request from $c$ for $a$ is currently being serviced by the directory.
\ref{dreqhandle}
\end{cons}
\begin{cons}
If $dir[c][a] = x$, a directory can send a response \Resp{Dir}{c}{a}{y} only if
$y > x$ and $dir[c][a]$ changes from $x$ to $y$ on sending the response.
\end{cons}
\begin{cons}
If there is a pending response from the directory for an address $a$, a cache
$c$ can not voluntarily send a downgrade response for address $a$ to the
directory. But $c$ can send a downgrade response to the directory if it is
servicing a downgrade request for address $a$ from the directory.
\ref{creqhandle}
\end{cons}
\begin{cons}
If $state[c][a] = x$, a cache $c$ can send a response \Resp{c}{Dir}{a}{y} only if
$y < x$ and $state[c][a]$ changes from $x$ to $y$ on sending the response.
\end{cons}
\begin{cons}
On servicing a response \Resp{Dir}{c}{a}{x}, the directory changes $dir[c][a]$
to $x$.
\end{cons}
\begin{cons}
On servicing a response \Resp{c}{Dir}{a}{x}, cache $c$ changes $state[c][a]$
to $x$.
\end{cons}
\begin{cons}
$state[c][a]$ can change only if cache $c$ sends a response to the directory or
services a response from the directory, for address $a$.
\end{cons}
\begin{cons}
$dir[c][a]$ can change only if the directory sends a response to cache $c$ or
services a response from cache $c$, for address $a$.
\end{cons}
\caption{Sending and servicing responses}
\label{sendRespPre}
\end{figure}

Figure \ref{sendRespPre} shows the the meta-rules regarding when responses can
be sent, and the state changes accompanying the sending and servicing of a
response. In these meta-rules, ``being serviced'' means having started the
servicing of a request.  For example, if servicing a request requires more
requests to be sent, ``being serviced'' corresponds to having started sending
those requests.

Meta-Rule \ref{creqhandle} prevents Scenario \ref{indisc} from happening. A
cache $c$ should not send a voluntary downgrade response \Resp{c}{Dir}{a}{I} if
it is waiting for a pending response from the directory, which was being
violated in that scenario ($c$ evicted address $a$ to replace it with address
$a'$ while still waiting for an upgrade response for $a$ from the directory).

Meta-Rule \ref{dreqhandle} states that a directory can not voluntarily send an
upgrade response to a cache. This again leads to Invariant \ref{conservative}
being violated. The intuition behind having meta-rules \ref{creqhandle} and
\ref{dreqhandle} is that they prevent ``crossing'' of two response messages as
shown in Figure \ref{crossing}. This preserves Invariant \ref{conservative}.

\begin{figure}
\begin{cons}
A request \Req{Dir}{c}{a}{x} can be sent only if there is no pending response
from cache $c$ for address $a$, and $x < dir[c][a]$ just before the directory
sends the request.
\label{dirreq}
\end{cons}
\begin{cons}
A request \Req{c}{Dir}{a}{x} can be sent only if there is no pending response
from the directory for address $a$, and $x > state[c][a]$ just before the
directory sends the request.
\label{creq}
\end{cons}
\begin{cons}
Requests from the directory for an address $a$ should be serviced even if there
is a pending response from the directory for any address (either $a$ or other
addresses).
\label{cblock}
\end{cons}
\caption{Sending and servicing requests}
\label{sendReqPre}
\end{figure}

Figure \ref{sendReqPre} shows the meta-rules regarding when requests can be
sent. If Meta-Rule \ref{cblock} is obeyed, then Scenario \ref{noprocess} will
be avoided.
