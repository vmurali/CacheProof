\section{Discussion}
\label{sec:discussion}

\subsection{Efficient bit encoding in directories}
The directory of a node store its version of the state for each of the node's
children. The directory encoding can be optimized using the Single-writer
Invariant \ref{singlewriter}.

For the MSI protocol, if a child is in $M$ state, every other child will be in
$I$ state, so just storing the index of the child in $M$ state is sufficient.
Otherwise, just a bit-vector, one bit for each child is sufficient to denote
which children are in $S$ state. Overall, for each line present in the node,
if a node has $n$ children, the directory requires $max(\lceil log_2(n)\rceil, n)
+ 1$ bits (the extra bit denotes if the value stored is the index, \ie a child
is in $M$ state or the bit-vector, \ie no child is in $M$ state). An additional
$2$ bits are needed to store the coherence state of the node with respect to its
parents. Even if MESI optimization is done, just $2$ bits for the coherence
state is enough, overall, to decide when the data of an address is dirty (just
like in normal MESI protocols). So MSI requires $max(\lceil log_2(n)\rceil, n)
+ 3$ bits per line. This is the same for the $M$-only cache intervention
protocol too.

In a MOSI protocol, a node's child can be in $O$ while multiple other caches are
still in $S$ state. Thus, for a node with $n$ children, the directory requires
$\lceil log_2(n)\rceil + n + 2$ bits per line. The additional two bits are
required to distinguish between 3 cases: a) if any cache is in $M$ state, in
which case only the index of the cache is relevant, or b) if any cache is in $O$
state, in which case both the index of the cache in $O$ state as well as the
bit-vector giving the list of caches in $S$ state is relevant, or c) every cache
is in a state $\le S$, in which case only the bit-vector is relevant. The
coherence state again requires $2$ bits as before, so overall, $\lceil log_2(n)
\rceil + 4$ bits are required per line.

\subsection{Can this framework be extended to sparse-map directories? To
non-inclusive or exclusive cache hierarchies?}
Our framework relies on full-map directories. If the directory sends a downgrade
request to a cache, the cache drops the request if the cache has already
downgraded its state Constraint \ref{drop-req}. This constraint has to be
changed to allow caches to respond notifying the directory that it has already
downgraded. We believe it is a straight-forward extension, but we haven't
formally proven if this works.

When caches are not inclusive, though the memory system is hierarchical with
respect to data tranfer, it not hierarchical with respect to coherence (as
every cache in every level has to be probed for downgrading). We believe that
such a system can be modeled within our framework as a two-level system, with
slightly different rules for compatibility between caches. For example, for
non-inclusive caches, two caches can have the same address in the $M$ state if
one cache is another's ancestor in terms of the data transfer hierarchy.

%\subsection{Are all the constraints \ref{} to \ref{} necessary to implement
%correct protocols?}
%As we discussed above, our framework requires full-map directory. Within the
%design space full-map directory protocols, we believe that all of these
%constraints are necessary to have a correct system.  To illustrate this, we will
%use the example of not imposing Constraint \ref{down-resp}, \ie a cache
%downgrades its state without sending a response to the directory.
%
%Consider the case of the simple MSI protocol. Let us assume cache $c$ downgraded
%its state from $M$ to $I$ without informing the directory. The directory might
%later send a downgrade to $I$ request to $c$, which will be dropped by $c$. Now
%the system would deadlock because the directory would not receive a response
%from $c$ ever.
%
%Consider the $M$-only cache-intervention based protocol. Here, the directory
%already sends an upgrade response (in the form of a forwarding message)
