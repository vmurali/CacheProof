\section{Conclusions and future work}

In this paper, we provided a formal definition of cache coherence via the store
atomicity property and provided a concrete hierarchy-parametric directory-based
MSI protocol whose correctness we formally checked via a Coq-based proof. To our
knowledge this is the first instance of a formal proof of a protocol parametric
over the cache hierarchy. We have also provided a set of invariants not
specific to MSI which imply store atomicity; other protocols that obey these
invariants are already proven to be correct. Finally, we have identified a set
of key properties that seem to be shared with many other protocols which ease
the verification considerably.

Our protocol is described in a style amenable to mechanical transliteration to a
Bluespec SystemVerilog hardware description allowing us to provide high-quality
verified cache coherence engines. As the protocol and associated proof are robust
to many microarchitecture-oriented changes (\eg{} arbitrary hierarchy and
arbitrary cache size, associativity, replacement policy choices, policies to
handle incoming requests, \etc{} in each node), we should be able to produce a
high performance performance formally verified hardware cache coherence system.

Moving this work towards generating a fully verified MSI implementation
requires a number of small steps. First, the simple transliteration of
descriptions between Bluespec and Coq, must be done in a mechanical way.
Second, the compilation of Bluespec to hardware is unverified; to fully trust
the implementation the Bluespec compiler must be verified. Some initial work on
this has already been done~\cite{TDBLP:conf/cav/BraibantC13}. Finally, we must
extend our notion of correctness to provide some guarantee of
liveness and fairness in handling of requests from processors. We have
initial Coq-based proofs that with finite buffers a local fairness in
transaction our protocol will have this property, but more work is needed to
fully resolve this venture. 





%% We illustrated a direct realization of our proposed proof framework for a
%% concrete MSI cache coherence protocol implementation codifying the intuition
%% behind the system's correctness as simple invariants. While this took
%% significant effort, once done, we showed that many key hardware
%% modifications,\eg{} replacement policies, could be made with a very small
%% addition to the proof. These bits were small enough that an informed hardware
%% designer implementing our protocols can reasonably be expected to provide such
%% additional proofs during refinement, producing a provably correct realistic
%% cache coherence engine implementation.

%% The protocol framework we showed was very flexible, and could easily be
%% extended for variants that go beyond micro-architectural variants, \eg{}
%% extension to MOSI with a relatively small amount of additional reasoning. This
%% gives us good confidence that we can effectively produce frameworks for other
%% classes of protocols, \eg{} update-based protocols, non-inclusive cache
%% hierarchies. Further, nothing about our methodology requires we limit ourselves
%% to cache coherence systems; this approach should naturally extend to any
%% hardware-based system.

%% While fundamentally this work meets our goal of verification of synthesizable
%% hardware specifications, there is still some important mechanization to make
%% this ready for industrial use. Foremost, the simple transliteration between the
%% inductively defined transition system in Coq and the Bluespec hardware
%% description should be fully mechanized.
%% %Further, the proposed extension to provide fairness of transaction scheduling
%% %in the Bluespec compiler should be implemented.
%% Further, to fully guarantee correctness of the resulting hardware, we should
%% also verify the hardware synthesis compiler, possibly using FeSi~\cite{Tomas}.


%%  LocalWords:  associativity atomicity
