\section{Conclusions and future work}

We illustrated a direct realization of our proposed proof framework for a
concrete MSI cache coherence protocol implementation codifying the intuition
behind the system's correctness as simple invariants. While this took
significant effort, once done, we showed that many key hardware
modifications,\eg{} replacement policies, could be made with a very small
addition to the proof. These bits were small enough that an informed hardware
designer implementing our protocols can reasonably be expected to provide such
additional proofs during refinement, producing a provably correct realistic
cache coherence engine implementation.

The protocol framework we showed was very flexible, and could easily be
extended for variants that go beyond micro-architectural variants, \eg{}
extension to MOSI with a relatively small amount of additional reasoning. This
gives us good confidence that we can effectively produce frameworks for other
classes of protocols, \eg{} update-based protocols, non-inclusive cache
hierarchies. Further, nothing about our methodology requires we limit ourselves
to cache coherence systems; this approach should naturally extend to any
hardware-based system.

While fundamentally this work meets our goal of verification of synthesizable
hardware specifications, there is still some important mechanization to make
this ready for industrial use. Foremost, the simple transliteration between the
inductively defined transition system in Coq and the Bluespec hardware
description should be fully mechanized.
%Further, the proposed extension to provide fairness of transaction scheduling
%in the Bluespec compiler should be implemented.
Further, to fully guarantee correctness of the resulting hardware, we should
also verify the hardware synthesis compiler, possibly using FeSi~\cite{Tomas}.

