\section{Refinements}
\label{sec:Refinements}

In this section we discuss important design changes of interest to
implementors and the impact it has on the verification. Most of these
require no change in the intuitive reasoning for correctness and thus
require no change to our Coq framework to prove correctness.

%We have formally proven the
%correctness of each of these choices in Coq, but due to space concerns we will
%not discuss them in their full detail. 


\subsection{Changing the caching policy}

Logically, The base protocol lacks an explicit representation of the
notion that caches have only a partial copy of the data; rather it
models it by having unincluded cache entries be in the \In state and
allowing voluntary transitions to evict any data as desired. This
provides enough flexibility to model any caching policy at the node
level.However, when realizing the protocol in hardware, we must
explicitly encode the restrictions into the design, \eg{} explicitly
providing finite memories for data and address tags. Showing such
design-level details preserve correctness is simply showing that we
have a correspondence between each hardware-oriented state
configuration and the base protocol state configurations, an easily
accomplished task.

\xxx{ndave: Can Coq do this automatically? That'd be a nice
  statement}.

\subsection{Implementing Unbounded pair-wise communication Channels}

In the base protocol, internode communication channels are assumed to
be infinite. Obviously to be implemented in hardware they must be made
finite which may introduce deadlocks as atomic transactions may not
apply if a buffer becomes full. However, we can see that no such
deadlock may happen as the protocol obeys weak forward
progress. Therefore some message will be consumed by the system
eventually if it exists.

\xxx{ndave: I don't understand why this is follows / is true. I'd also like to fold in the discussion of sharing the separate channels into a physical layer, but not the grid / communication fabric stuff here}

\subsection{Implementing unbounded pair-wise communication channels in real hardware}

\xxx{ndave: Given previous subsection, this is just focused on the network}

In order to implement the unbounded pair-wise communication channels that we
assumed in Figure~\ref{trans} and throughout Section \ref{safety}, we need
to prove that a) finite buffers are sufficient, b) provide a mapping from
pair-wise communication channels to an interconnect network such as a ring or a
mesh and c) prove that such a mapping does not cause deadlocks.

In order to prove that finite buffers are sufficient to avoid deadlocks, it is
sufficient to observe that the protocol obeys weak forward progress. Therefore
some message will be consumed by the system eventually if it exists.

We will now describe the mapping from pair-wise communication channels
to interconnnect network in greater detail, and informal arguments
about why the mapping is necessary and sufficient.

\begin{enumerate}
\item Each level in the cache hierarchy has a single separate virtual network
for requests from child to parent. This need not maintain FIFO order.
\item Either
\begin{enumerate}
\item there are 2 separate virtual networks overall (shared by all the levels)
for responses from child to parent. The first network carries responses sent by
children who were in state \Mo{} when sending the response and the second
carries response sent by children in state \Sh{} when sending the response.
Neither of these two virtual networks need to maintain FIFO order or
\item there is a single virtual network overall (shared by all the levels) for
responses from child to parent, which maintains a FIFO order.
\end{enumerate}
\item Each level in the cache hierarchy has a single separate virtual network
for both request and response messages from the parent to the child. This
network has to maintain FIFO order between messages with the same
source-destination pair.
\end{enumerate}

The intuition behind this virtual network allotment is as follows. Requests and
responses sent by a parent to its child need to maintain FIFO order, in order
to satisfy Invariant \textit{noCross}. Any response message sent to the parent
will be drained by execution of either ParentRecvResp transitions, hence these
messages can share a virtual network across the whole hierarchy. In the case of
responses, FIFO property can be enforced at the protocol itself (in fact the
transitions in Figure \ref{trans} ensures the FIFO property of responses from
child to parent without requiring the network to provide them). The need for 2
separate virtual networks is to avoid head of line blocking in case the
messages go out of order. If FIFO property is maintained, then the messages
will not go out of order, and hence a single virtual network is sufficient.
Since any request can generate new requests (unlike responses), the new
requests should be sent on different virtual networks to prevent deadlocks,
hence the need for separate virtual channels for requests at each level of the
hierarchy.

We do not provide the formal proofs for the above assertions due to lack of space.

\subsection{Protocol}
We will describe two important protocol variations, the MESI and MOSI protocols
in which all the invariants that we mention in Section \ref{safety} hold.

In the MESI protocol, there is just one difference from the MSI protocol of
Figure \ref{trans}. A cache, in addition to the states mentioned in Section
\ref{sec:System}, contains a ``dirty'' boolean value associated with each
address.  Whenever a cache gets new data from its parent, this value is set to
\False{} and becomes \True{} whenever the a store request is processed in that
cache, or if the cache receives data from its children. It simply denotes
whether the data in the cache matches that of its parent or not.  Whenever a
child downgrades from \Mo{}, when the data is not dirty, instead of sending the
non-updated data back to the parent, a special response message indicating that
the data has not been updated is sent. Proving that this protocol obeys the
invariants in Section \ref{safety} is straightforward.

A more interesting variation is the MOSI protocol (and it's E-variant MOESI --
similar to the MESI variant of MSI). In this, a new state called \Ow{} is
introduced. A cache in \Ow{} state for an address has only read permissions for
that address, but the data it holds is more up-to-date than that in the parent.
All its siblings in the \Sh{} state also have the most up-to-date data.
Whenever data has to be supplied to a new cache $c$, the parent directs a
sibling of $c$ in the \Ow{} or \Mo{} state (if any) to supply the data to $c$.

The invariants in Section \ref{safety} almost holds as is in this protocol too,
except for the definition of compatibility between two states and Invariant
\textit{localCompatibility}. If a state is in \Ow{}, then it is compatible only
with another state in \Sh{} or \In{}. The total order for the states is now
($\Mo > \Ow > \Sh > \In$). A child cache always requests an upgrade to \Ow{}
instead of \Sh{} whenever it requires read permission. The second clause of
Invariant \textit{localCompatibility} is no longer true. Instead, we can prove
a weaker clause, \viz, the states of two siblings for an address are compatible
(instead of the directory entries at the parent for the two siblings being
compatible).  This is because in the protocol, the parent sends an upgrade, say
to cache $c$, for \Ow{} or \Mo{} inspite of another cache, say $c'$, being in
\Ow{} or \Mo{} state. But the parent also sends a downgrade request to $c'$
simultaneosly. The request-response message first reaches $c'$. If $c'$ has
already downgraded (using a transition similar to ChildVolResp), then it drops
the request-response message, and the parent falls back to normal MSI-like
transitions, otherwise $c'$ downgrades its state, and sends a downgrade
response, along with the upgrade response to $c$ from the parent, both to $c$.
$c$ then performs the upgrade, and sends the downgrade response from $c'$ to
the parent. This gives the intuition behind why the siblings are compatibly
inspite of the directory states not being compatible.

The proof of Invariant \textit{noTransitWrite} is also different in this
protocol. One must analyze three caches, the parent and two siblings in order
to prove the invariant. The proof, as in MSI protocol, requires Invariant
\textit{noCross} and \textit{respFIFO}.

The bulk of the store atomicity proof, which requires proving Invariant
\textit{conservative} remains the same as in the MSI protocol.
