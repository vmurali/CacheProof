\section{Extending the proof to other protocols}
\label{sec:Refinements}

In this section we consider the complications in proving the invariants
of Section~\ref{safety} for the MESI, MOSI, and MOESI protocols.

The MESI protocol is a minor variation of the MSI protocol discussed in Section~\ref{sec:System}.
A cache, in addition to the states mentioned in Section
\ref{sec:System}, contains a ``dirty'' Boolean value associated with each
address.  Whenever a cache gets new data from its parent, this value is set to
\False{} and becomes \True{} whenever a store request is processed in that
cache, or if the cache receives data from its children. The flag simply denotes
whether the data in the cache matches that of its parent.  Whenever a
child downgrades from \Mo{}, when the data is not dirty, instead of sending the
non-updated data back to the parent, a special response message indicating that
the data has not been updated is sent (to reduce the size of the message being
sent). Proving that this protocol obeys the invariants in Section~\ref{safety}
is straightforward.

A more interesting variation is the MOSI protocol (and its E-variant MOESI --
similar to the MESI variant of MSI). Here a new state called \Ow{} is
introduced. A cache in \Ow{} state for an address has only read permissions for
that address, but the data it holds is more up-to-date than in the parent.  All
its siblings in the \Sh{} state also have the most up-to-date data, and none of
the siblings can be in \Mo{} or \Ow{} state.  Whenever data has to be supplied
to a new cache $c$, the parent directs a sibling of $c$ in the \Ow{} or \Mo{}
state (if any) to supply the data to $c$.

Since Invariant~\fullref{conservative} depends solely on the fundamental Invariants~\fullref{stateChange}, \fullref{noCross} and \fullref{respFIFO}, it holds true
as long as the 3 fundamental invariants hold (which is the case in the MOSI
protocol). The proof of Invariant~\fullref{localCompatibility1} in MOSI is more
or less the same as in MSI.

Proving the Invariants~\fullref{localCompatibility2} and
\fullref{noTransitWrite} is more involved. The parent's directory can
simultaneously have two distinct children in the $\Mo$ or $\Ow$ states,
preventing the reuse of their proofs in MSI \emph{as is}. Unlike in MSI, where
analysis of a parent-child pair was more or less sufficient to prove all the
invariants, one has to analyze a parent-child-sibling triple in MOSI.
