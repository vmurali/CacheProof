\section{Intuition}

In this section we give the proof of the MSI cache coherence protocol. We give
the proof in a top-down fashion starting with the store atomicity theorem. We
specify important invariants and show how they are proved in the MSI protocol.
In Section \ref{Refinements} show how these invariants hold in other protocols
like MESI and MOSI. These invariants are true at each step in the (infinite)
list of transitions starting from the initial state. We use the term time $t$
to specify the global state reached after $t$ transitions.  All the invariants
below pertain to a particular address; we will implicitly assume a universal
quantification over all address as a prefix to each of the invariants (if not
explicitly mentioned).

\subsection{Top invariants}
\begin{defn}
\textit{clean}: A cache is said to be \clean{} for an address iff the state of the
cache is at least \Sh{} and the state of all its children is at most \Sh.
\end{defn}
\begin{inv}
At any time $t$, a cache $c$ which is clean for an address $a$ will have the most
up-to-date value for that address, \ie
\begin{enumerate}
\item $c.\data[a] = \initData(a)$ and no store request has been processed at
any time $< t$, or
\item There is a store request $q$ that was processed at time $t'$ such that
$t' < t$ and $a = q.\addrQ \wedge c.\data[a] = q.\dataQ$ and no other store
request $q'$ was processed at any time $t_i$ such that $t' < t_i < t \wedge a =
q'.\addrQ$.
\end{enumerate}
\label{latestValue}
\end{inv}

The following invariants hold for leaf caches.
\begin{inv}
\textit{uniqM}: At all times, at most one leaf cache can be in \Mo{} state.
\label{uniqM}
\end{inv}

\begin{inv}
\textit{processReq}: At all times, a load or a store request at a leaf cache can be processed
only if it is at least in \Sh{} or \Mo{} state at that time, respectively.
\label{processReq}
\end{inv}

\begin{inv}
\textit{noReqAgain}: A leaf cache $c$ processes the $c.\pos^{th}$ request iff
$c.\pos$ changes. $c.\pos$ only gets incremented when it changes.
\label{noReqAgain}
\end{inv}

Using Invariants \ref{latestValue} to \ref{noReqAgain}, it is easy to see that
Theorem \textit{storeAtomicity} can be proved. Since a store can happen only
when the state of a leaf cache is in \Mo{} state (Invariant
\textit{processReq}), because of Invariant \textit{uniqM} only one store
request can be processed at a time throughout the system, thereby satisfying
\textit{uniqStTimes}. Because of Invariant \textit{noReqAgain}, once a response
has been produced for a request $i$, the cache can only process requests $j, j
> i$. Thus there is at most one response to each request, satisfying
\textit{uniqRespLabels}. A load request can be processed only if a cache is at
least in \Sh{} state according to Invariant \textit{processReq}.  When a leaf
cache is at least in \Sh{} state, since it has no children, it is \clean{}.
Thus, by Invariant \textit{lastestValue}, the final condition for Theorem
\textit{storeAtomicity} is satisfied.

Note that Invariants \textit{processReq} and \textit{noReqAgain} can be proved
directly from the atomic transitions describing the system (Figure \ref{trans}
for MSI; other protocols must also have similar transitions). Proving Invariants
\textit{uniqM} and \textit{latestValue} requires the following invariants.

\begin{inv}
\textit{conservative}: At all times, the state of a cache is not greater than
its parent's directory corresponding to the cache.
\label{conservative}
\end{inv}

\begin{inv}
\textit{stateCompat}: At all times, the state of a cache is not less than its
directory corresponding to any of its children.
\label{stateCompat}
\end{inv}

We use the definition of compatibility between two caches as follows:
\begin{defn}
\textit{compatibile}: At some time, cache $c_1$ is compatible with $c_2$ iff
at that time,
\begin{enumerate}
\item $c_1.\state[a] = \In$ whenever $c_2.\state[a] = \Mo$ and
\item $c_1.\state[a] \le \Sh$ whenever $c_2.\state[a] = \Sh$
\end{enumerate}
\label{compatible}
\end{defn}

\begin{inv}
\textit{siblingCompat}: At all times, two sibling caches (\ie caches with the
same parent) are compatible.
\label{siblingCompat}
\end{inv}

\begin{inv}
\textit{noTransitWrite}: When a cache $c$ transitions from non-clean at time
$t$ to clean at time $t+1$ for an address $a$, then it receives data $a$ from
some cache $s$ such that the $s$ is clean at the time $t'$ for address $a$, and
no store request was processed for $a$ at time $t_i$ such that $t' \le t_i \le
t$.
\label{noTransitWrite}
\end{inv}

For any two caches $c$ and $p$, such that $c$ is a descendent of $p$ in the cache
hierarchy (the descendent relation between two caches is the transitive
reflexive closure of the parent relation), from Invariants
\textit{conservative} and \textit{stateCompat}, it is clear that for any
address $a$, $c.\state[a] \le p.\state[a]$. Any two caches $c_1, c_2$ in which
neither is the decendent of the other will have a lowest common ancestor $x$
such that both the caches are descendents of $x$ and $c_1, c_2$ are descendents
of distinct caches $x_1, x_2$, respectively, such that $x_1, x_2$ are children
of $x$. $x_1$ and $x_2$ are compatible because of Invariant
\textit{siblingCompat}. $c_1.\state[a] \le x_1.\state[a]$ and
$c_2.\state[a] \le x_2.\state[a]$ because of Invariants \textit{conservative}
and \textit{stateCompat}. From this, it can easily be seen from the definition
of compatible that $c_1$ and $c_2$ are compatible whenever $x_1$ and $x_2$ are
compatible. From the definition of compatible it can be seen that both caches can not
be in the \Mo{} state for them to be compatible. This directly proves Invariant
\textit{uniqM}.

Invariant \textit{latestValue} can be proved using induction on time. Let us
assume that all caches which are clean at time $t'$ such that $t'<t+1$ have the
latest value. If a cache $c$ is clean at time $t$, then none of its descendents
are in \Mo, and hence none of its descendents can process a store request at
$t$. Any non descendent is compatible with it (as shown in the previous
paragraph) and so no non-descendent cache can be in \Mo, since a clean cache is
at least in \Sh. So only $c$ can process a store request at $t$ (assuming $c$
is a leaf cache and is in state \Mo) when it is clean, and no other cache can
process a store request. By induction hypothesis, it contained the latest value
at time $t$ which remains true (because of no processing of store request) at
time $t+1$. Now, if a cache was not clean at time $t$, then it would have
received the data from some cache which was clean at the time of sending the
data (by Invariant \textit{noTransitWrite}), which means the data is the latest
value by induction hypothesis, so the new data it receives at time $t$ is the
latest value, making the clean cache at time $t+1$ have the latest value.

Invariant \textit{conservative} can be proved by
further breaking them into the following invariants between a parent-child pair
of caches.

\begin{inv}
\textit{stateChange}:
\begin{enumerate}
\item A child sends a response to its parent iff it downgrades its state.
\item A parent sends a response to a child iff it upgrades the directory of
that child.
\item The state and the directory can change only on sending and receiving a
response; the receiving entity changes its value to that of the sending entity
immediately after sending the response message.
\end{enumerate}
\label{stateChange}
\end{inv}

\begin{inv}
\textit{respFIFO}: Responses are received in the order in which they are sent,
for a source-destination pair, for the same address.
\label{respFIFO}
\end{inv}

\begin{inv}
\textit{noCross}: A response from a cache to its child for an address can not
be in transit while another response from the same child to the parent for the
same address is in transit.
\label{noCross}
\end{inv}

Invariant \textit{conservative} at any time $t$ for child cache $c$ and parent
$p$ for an address $a$ can be proved as follows. Consider the case when
$c.\state[a]$ never changed before $t$, then $c.\state[a] = \In$ because of the
initialization conditions described in Section \ref{System}. No response would
have been sent by $c$ to its parent for address $a$ before $t$, otherwise
$c.\state[a]$ would have changed. Thus the parent would not have received any
response from $c$, $p.\dstate[c][a]$ could have changed only by sending a
response to $c$ which can only upgrade it from the initial value of $\In$. Thus
at $t$, $p.\dstate[c][a] \ge c.state[a]$.

Now consider the case when $c.\state[a]$ last changed at $t'$ such that $t' <
t$ because of receiving a response from $p$, sent at $t''$. $c.\state[a]$ at
$t'+1 = p.\dstate[c][a]$ at $t''+1$ because of Invariant \textit{stateChange}.
$c$ neiter sends nor receives a response at any $t_i$ such that $t' < t_i < t$.
If $p$ received a response at some $t_m$ such that $t'' < t_m < t$,
then it would either violate Invariant \textit{noCross}, or the fact that no
message was sent between $t' < t_i < t$ from $c$. Thus, $p.\dstate[c][a]$ at $t
\ge p.\dstate[c][a]$ at $t''+1$ because any message sent can only upgrade
$p.\dstate[a]$. This ensures that Invariant \textit{conservative} is obeyed. We
can similarly prove this invariant holds when $c.\state[a]$ last changes before
$t$ by sending a response.

Invariant \textit{stateChange} can be proved directly from the atomic
transitions for MSI. Other protocols have similar atomic transitions obeying
these invariants.

Invariant \textit{respFIFO} can be enforced by the interconnect network which
ensures a FIFO ordering for messages sent between a pair of nodes.

---------------------------------------------

%Invariant \textit{respFIFO} is known as point-to-point FIFO ordering in the
%Network-on-Chip NoC community, and is enforced by common routing algorithms
%like Dimension-ordered routing \cite{dimension}. Only the parent-to-child
%channels need to be FIFO ordered, the FIFO ordering in child-to-parent channels
%can be enforced using the protocol itself.

\begin{inv}
\textit{noTransitEqual}: When no response is in transit for an address, then
the state of a cache for that address is the same as its parent's directory for
that cache and address.
\label{noTransitEqual}
\end{inv}

Proving Invariants \textit{inTransitCondition} and \textit{noTransitEqual},
needs two further invariants, along with Invariant \textit{stateChange}.

Invariant \textit{inTransitCondition} can be proved as follows. Whenever a
response from a child to the parent is in transit, the parent can not send any
response to the child, or it will violate Invariant \textit{noCross}. Using the fact that 







\begin{inv}
\textit{inTransitCondition}:
\begin{enumerate}
\item When a response is sent from a child $c$ at time $t$ for an address $a$,
and has not been received by the parent $p$ before time $t'$, $\forall t_i, t <
t_i \le t' @-> c.\state[a]$ at $t_i \le c.\state[a]$ at $t+1$ and $\forall t_i,
t \le t_i \le t' @->$ $p.\dstate[c][a]$ at $t_i \ge c.\state[a]$ at $t$.
\item When a response is sent from parent $p$ at time $t$ for an address $a$,
and has not been received by its child $c$ before time $t'$, $\forall t_i, t <
t_i \le t' @-> p.\dstate[c][a]$ at $t_i \ge p.\dstate[c][a]$ at $t+1$ and
$\forall t_i, t \le t_i \le t' @->$ $c.\state[a]$ at $t_i \le p.\dstate[c][a]$ at
$t$.
\end{enumerate}
\label{inTransitCondition}
\end{inv}

\begin{inv}
\textit{prevState}: When a response is received from a child to the parent
(parent to child) for an address, the state of the child for that address at
the time of sending (receiving) the response is the same as the parent's
directory for that child and address at the time of receiving (sending) the
response.
\label{prevState}
\end{inv}



%Top
%a) conservative: forall p c a t, parent c p -> dir p c a t >= state c a t
%b) forall p c a t, parent c p -> state p a t >= dir p c a t
%c) forall c1 c2 a t, sibling c1 c2 -> compatible c1 c2 a t
%d) nextClean: ~ clean c a t -> clean c a (S t) -> exists s d ts, recv data s a t d /\ send data s a ts d /\ clean s a ts /\ ts <= t /\ forall ti, ts <= ti < t ->  ~ write a ti
%
%(from=state(t1)=dir(t2) -> betweenPSendCRecv:dir(t)>=to&state(t)<=from, betweenCSendPRecv:state(t)<=to&dir(t)>=from), noMesgImp:state(t)=dir(t) -> conservative (ignore from=, use only a, b)
%a) Child sends message iff it downgrades
%b) Parent sends message iff it upgrades
%c) State is changed only on sending or receiving a message
%d) FIFO messages
%e) cross: Message from child and parent do not cross
%
%cross:
%a) parent send message only on receiving request
%b) req from child does not overtake response from child (prove using the from states)
%c) resp from parent does not overtake request from parent
%d) voluntary response sent from child only when not waiting
%
%In this section we specify a set of important invariants for a parent-child pair of caches.
