\section{Proof of MSI protocol being sound wrt Store atomicity}
\label{safety}

In this section, we present the proof structure for the soundness
property of our MSI-based cache coherence protocol of
Figure~\ref{trans}. Specifically, we formally reduce the proof of the
store atomicity theorem for the whole system to the proof of a set of
simple invariants by leveraging the ``intuitive'' justification of
correctness of our protocol.

%% This intuition
%% is not restricted to the MSI-based protocol;
%% Section~\ref{sec:Refinements} shows that it applies can apply to other
%% protocols.

Our invariants hold after any series of executions of the component
transactions of our design reachable from the initial state. We use
the term time $t$ to specify the global state reached after firing $t$
transitions.

While we have proofs in Coq of each step in this framework our
discussion will be mainly informal for brevity. A full description can
be found at~\xxx{MURALI PUT REFERENCE HERE}.

\subsection{Reducing correctness to Node-level Invariants}

The store atomicity is a whole system property. Intuitively our
protocol is correct because it guarantees that at most one node can
write at a time, and that any local cache that attempts to read has
the ``latest'' value. We can state this formally with the following 4
invariants about nodes:

\begin{defn}
\textit{clean}: A cache is said to be \clean{} for an address $a$ if and only if
the state of the cache for that address is at least \Sh{} and the
state of all its children is at most \Sh.
\end{defn}
\begin{inv}
At any time $t$, a cache $c$ which is clean for an address $a$ will have the most
up-to-date value for that address, \ie{}
\begin{enumerate}
\item $c.\data[a] = \initData(a)$ and no store request has been
  processed at any time $t_i$ such that $t_i < t$, or
\item There is a store request $q$ that was processed at time $t'$ such that
$t' < t$ and $a = q.\addrQ \wedge c.\data[a] = q.\dataQ$ and no other store
request $q'$ was processed at any time $t_i$ such that $t' < t_i < t \wedge a =
q'.\addrQ$.
\end{enumerate}
\label{latestValue}
\end{inv}

We use the definition of compatibility between two caches as follows:
\begin{defn}
\textit{compatibile}: Values of states $x_1$ and $x_2$ are compatible if and only if
either $x_1$ or $x_2$ is \Mo{}, then the other is \In.
\label{compatible}
\end{defn}

\begin{inv}
\textit{nonAncestorCompatible}: For two distinct caches $c_1$ and $c_2$ such
that neither is an ancestor of the other in the cache tree hierarchy, for each
address $a$, $c_1.\state[a]$ and $c_2.\state[a]$ are compatible.
\label{nonAncestorCompatible}
\end{inv}

\begin{inv}
\textit{processReq}: A load (store) request for an address at a leaf cache can
be processed only if it is at least in the \Sh{} (\Mo) state for that address.
\label{processReq}
\end{inv}

\begin{inv}
\textit{noReqAgain}:
\item For a leaf cache $c$, $c.\pos$ changes only on processing a request in
which case $c.\pos$ is incremented.
\label{noReqAgain}
\end{inv}

Given these invariants, we codify our intuition by showing that
Theorem~\fullref{storeAtomicity} follows naturally from these
invariants.  A store may happen only when leaf cache is in \Mo{} state
for that address (Invariant~\fullref{processReq}). Leaf caches cannot
be ancestors of any other node, so by Invariant
\fullref{nonAncestorCompatible}, if a leaf cache is in \Mo{} state, all
other leaf caches will be in \In{} state preventing the possibility of
load and store requests for the same address (by Invariant
\fullref{processReq}), showing Definition~\fullref{uniqStTimes} holds.

Given Invariant~\fullref{noReqAgain}, once a response has been produced
for a request $i$, the cache may subsequently only process $j^{th}$
request such that $j > i$. Thus there is at most one response to each
request, satisfying Definition~\fullref{uniqRespLabels}. A load request
may be processed only if a cache is at least in \Sh{} state (Invariant
\fullref{processReq}). As leaf caches have no children, a leaf cache in
at least in \Sh{} state for address $a$ is \clean for that address. A
load response supplies the data for that address present in the cache,
which, by Invariant~\fullref{lastestValue}, contains the ``latest
value''. Thus, the final condition for Theorem~\fullref{storeAtomicity}
is also satisfied. All that remains is to show that these properties hold.

\subsection{Reducing to Pair-wise Invariants}
\label{pairwise}

We can directly show that Invariants~\fullref{processReq} and
\fullref{noReqAgain} hold at the initial configuration and are
preserved through each atomic transition of our protocol
(Figure~\ref{trans}). Invariants~\fullref{uniqM} and
\fullref{latestValue} correctness rely on properties of the node
hierarchy. We can prove both using the following invariants on
parent-child relationships.

\begin{inv}
\textit{conservative}: The state of an address in a cache is never greater than
the corresponding entry in the parent's directory.
\label{conservative}
\end{inv}

\begin{inv}
\textit{localCompatibility}:
\begin{enumerate}
\item The state of a cache is never less than its directory entry for any of
its children.
\item Let $c_1$ and $c_2$ be distinct caches with the same parent $p$. Then,
$p.\dstate[c_1][a]$ and $p.\dstate[c_2][a]$ are compatible.
\end{enumerate}
\label{localCompatibility}
\end{inv}

\begin{inv}
\textit{noTransitWrite}: Whenever data for an address $a$ is in transit (\ie{}
$\forall t, t_s \le t \le t_r$ where $t_s$ is the time of sending the data and
$t_r$ the time of receiving the data), no cache can process a store request for
$a$.
\label{noTransitWrite}
\end{inv}

For any two caches $c$ and $p$, such that $p$ is an ancestor of $c$ in
the cache tree hierarchy, from Invariants \fullref{conservative} and
\fullref{localCompatibility}, we can show that for any address $a$,
$c.\state[a] \le p.\state[c][a]$. This is because the ancestor
relation is the reflective-transitive closure of the parent relation,
and Invariants \fullref{conservative} and the first part
\fullref{localCompatibility} of defines a $\ge$ relation between the
states of a parent and its child.

Any two caches $c_1, c_2$ neither of which are an ancestor of the
other will have a lowest common ancestor $x$ which is an ancestor of
both $c_1$ and $c_2$ and has two distinct children $x_1$ and $x_2$
such that they are the ancestors of $c_1$ and $c_2$ respectively. For
any address $a$, $x.\dstate[x_1][a]$ and $x.\dstate[x_1][a]$ are
compatible by the second part of
Invariant~\ref{localCompatibility}. From this, it straightaway follows
that $x_1.\state[a]$ and $x_2.\state[a]$ are compatible (from
Invariant~\ref{conservative}). From the previous paragraph, it follows
that $c_1$ and $c_2$ are also compatible. This proves
Invariant \fullref{nonAncestorCompatibility}.

We prove Invariant \fullref{latestValue} by strong induction on
time. Consider two cases: cache $c$ is already \clean{} for an address
$a$ at time $t$ or the contrary.  If \clean{}, then it has the latest
value at time $t$. Since none of its children's directory entries can
be in \Mo{}, all its descendants should be no greater than \Sh{} for
that address (as discussed above). Any non-ancestor of $c$, and
non-descendant of $c$ must be compatible (as discussed above). Since
$c$ is \clean, it is at least in the \Sh{} state, so compatibility
means that non-descendants can not be in \Mo{} state. All of $c$'s
ancestors are non-leaves, so they can not process any store
request. Therefore, no cache save $c$ may have process a store
request, which means that $c$ contains the latest value for address
$a$ at time $t+1$ if it was \clean{} at time $t$.

If $c$ was not clean at time $t$, it must have received data from
either its parent or its child.  As can be seen in Figure~\ref{trans},
whenever data is sent either from a parent to a child, or from a child
to the parent, the sender is \clean. By the induction hypothesis, it
means that the sender has the latest value for the address. Because of
Invariant~\ref{noTransitWrite}, no store request can be processed when
the data is in transit, which means $c$ will have the latest value for
address $a$ at time $t+1$. 

\subsection{Proving parent-child hierarchy properties}

%ndave: This needs some repointing

We present two basic invariants that the MSI protocol of
Figure~\ref{trans} obeys. In fact the protocol (\ie{} the
request/response message semantics) was designed to ensure the
following two invariants. We believe that most cache-coherence
protocols would end up obeying these two invariants; we show how MOSI,
for instance, obeys these invariants in
Section~\ref{sec:Refinements}. These two invariants together can prove
all the pair-wise properties of Section~\ref{pairwise}.

The transitions of the protocol are setup so that the following invariant holds:
\begin{inv}
\textit{noCross}: A response from a cache to its child for an address can not
be in transit while another response from the same child to the parent for the
same address is in transit.
\label{noCross}
\end{inv}

In addition, the following invariant must hold regarding the order of responses
between the same pair of nodes:
\begin{inv}
\textit{respFIFO}: Responses are received in the order in which they are sent,
for a source-destination pair, for the same address.
\end{inv}

The MSI-based protocol in Figure~\ref{trans} is such that any change in either
the state of a cache or its directory entry takes place only on sending or
receiving a response. The parent upgrades the corresponding directory entry on
sending a response to a child and the child downgrades its directory entry on
sending a response to the parent.

To prove Invariant \fullref{conservative} at some time $t$, consider the case
when a child cache $c$ has sent to or received from the parent $p$ some message
before $t$. Consider the last such message $m$ sent by or received at $c$ at
$t'$. Let's say $m$ is sent by $c$. Then $p$ can not have received any message
from $c$ after sending $m$ in order to not violate Invariant \fullref{noCross}.
Instead, if $c$ receives $m$ at $t'$, $p$ will not receive any message after
sending $m$ in order to not violate Invariants \fullref{noCross} and
\fullref{respFIFO}. Let $m$ be sent or received by $p$ at $t''$. In both cases,
$p.\dstate[c][a]$ at $t''+1$ will be equal to $c.\state[a]$ at $t'+1$ (because
the response messages sync up the next-state according to the transitions in
Figure \ref{trans}). Since $p$ can not receive any message between $t''+1$ and
$t$, it can only upgrade $p.\dstate[c][a]$. Since $c.\state[a]$ does not change
between $t'+1$ and $t$, Invariant \fullref{conservative} holds at $t$. If no
message has been sent or received by $c$ before $t$, then $p$
wouldn't have received any message sent by $c$ before $t$ as it means that the
message must be sent by $c$ before $t$. Since the initial states of the
directory and the child's state are both set to \In{}, the same argument holds
(in which the parent can only upgrade), thus maintaining Invariant
\fullref{conservative}.

To prove Invariant \fullref{localCompatibility}, it is enough to show that a
child $c$ upgrades $c.\state[a]$ on receiving a response for $a$ from its
parent $p$ and $p.\dstate[c][a]$ is downgraded on receiving a response for $a$
from $c$. If this is true, then Invariant \fullref{localCompatibility} will not
be violated on receiving a response. The transitions of Figure \ref{trans}
ensures that Invariant \fullref{localCompatibility} is not violated when sending
a response.

If the value of the state of a child at the time of sending a response is the
same as the value of the directory for that child at the parent at the time of
receiving the response, it follows straightaway that the parent downgrades its
directory on receiving a response from the child, since a child downgrades on
sending a response and the next-states are synced on receiving the response.
The proof for this follows exactly the same arguments presented above to prove
Invariant \fullref{conservative} -- we prove by considering the last message
sent or received at the child before $t$ (and the case when no message has been
sent or received).

Invariant \fullref{noTransitWrite} can be proved as follows. Consider a response
sent from a parent $p$ at time $t$ received by its child $c$ at time $t'$. No
other response can be received by the parent at time $t_p$ such that $t+1 \le
t_p \le t'$ to not violate Invariant \fullref{noCross}, so $p.\dstate[c][a]$ at
$t+1 \le p.\dstate[c][a]$ at $t'$, since the parent can only upgrade its
directory for $c$. Similarly, no response can be sent by the child at time
$t_c$ such that $t \le t_c \le t'$ for the same reason and hence $c.\state[a]$
at $t \le c.\state[a]$ at $t'$ since the child can only downgrade its state.
This means that during $t_p$ such that $t+1 \le t_p \le t'$, $p.\dstate[c][a]
> \In$ since the parent upgraded its directory for $c$ at $t$. Similarly,
during $t_c$ such that $t \le t_c \le t'$, $c.\state[a] < \Mo$ since the
child upgrades its state at $t'$. Using arguments similar to the proof of
Invariant \fullref{latestValue}, we can establish that no cache can be in \Mo{}
state for address $a$ when a response is in transit from $p$ to $c$.
Similarly, we can prove that no cache can be in \Mo{} state for address $a$
when a response is in transit for address $a$ from $c$ to $p$. Since data is in
transit at the same time as when the response is in transit, Invariant
\fullref{noTransitWrite} follows.

%from the parent and child respectively, it is sufficient to show that the previous state
%or the 
%
%Invariant~\fullref{conservative} can be proved by
%further breaking them into the following invariants between a parent-child pair
%of caches.
%
%\begin{inv}
%\textit{stateChange}:
%\begin{enumerate}
%\item A child sends a response to its parent iff it downgrades its state.
%\item A parent sends a response to a child iff it upgrades the directory of
%that child.
%\item The state and the directory can change only on sending and receiving a
%response; the receiving entity changes its value to that of the sending entity
%immediately after sending the response message.
%\end{enumerate}
%\label{stateChange}
%\end{inv}
%
%\begin{inv}
%\textit{respFIFO}: Responses are received in the order in which they are sent,
%for a source-destination pair, for the same address.
%\label{respFIFO}
%\end{inv}
%
%\begin{inv}
%\textit{noCross}: A response from a cache to its child for an address can not
%be in transit while another response from the same child to the parent for the
%same address is in transit.
%\label{noCross}
%\end{inv}
%
%Invariant~\fullref{conservative} at any time $t$ for child cache $c$ and parent
%$p$ for an address $a$ can be proved as follows. Consider the case when
%$c.\state[a]$ never changed before $t$, then $c.\state[a] = \In$ because of the
%initialization conditions described in Section \ref{System}. No response would
%have been sent by $c$ to its parent for address $a$ before $t$, otherwise
%$c.\state[a]$ would have changed. Thus the parent would not have received any
%response from $c$, $p.\dstate[c][a]$ could have changed only by sending a
%response to $c$ which can only upgrade it from the initial value of $\In$. Thus
%at $t$, $p.\dstate[c][a] \ge c.state[a]$.
%
%Now consider the case when $c.\state[a]$ last changed at $t'$ such that $t' <
%t$ because of receiving a response from $p$, sent at $t''$. $c.\state[a]$ at
%$t'+1 = p.\dstate[c][a]$ at $t''+1$ because of Invariant \fullref{stateChange}.
%$c$ neiter sends nor receives a response at any $t_i$ such that $t' < t_i < t$.
%If $p$ received a response at some $t_m$ such that $t'' < t_m < t$,
%then it would either violate Invariant \fullref{noCross}, or the fact that no
%message was sent between $t' < t_i < t$ from $c$. Thus, $p.\dstate[c][a]$ at $t
%\ge p.\dstate[c][a]$ at $t''+1$ because any message sent can only upgrade
%$p.\dstate[a]$. This ensures that Invariant \fullref{conservative} is obeyed. We
%can similarly prove this invariant holds when $c.\state[a]$ last changes before
%$t$ by sending a response.
%
%Invariant \fullref{stateChange} can be proved directly from the atomic
%transitions for MSI. Other protocols have similar atomic transitions obeying
%these invariants.
%
%Invariant \fullref{respFIFO} can be enforced by the interconnect network which
%ensures a FIFO ordering for messages sent between a pair of nodes.
%
%---------------------------------------------
%
%%Invariant \fullref{respFIFO} is known as point-to-point FIFO ordering in the
%%Network-on-Chip NoC community, and is enforced by common routing algorithms
%%like Dimension-ordered routing \cite{dimension}. Only the parent-to-child
%%channels need to be FIFO ordered, the FIFO ordering in child-to-parent channels
%%can be enforced using the protocol itself.
%
%\begin{inv}
%\textit{noTransitEqual}: When no response is in transit for an address, then
%the state of a cache for that address is the same as its parent's directory for
%that cache and address.
%\label{noTransitEqual}
%\end{inv}
%
%Proving Invariants \fullref{inTransitCondition} and \textit{noTransitEqual},
%needs two further invariants, along with Invariant \fullref{stateChange}.
%
%Invariant \fullref{inTransitCondition} can be proved as follows. Whenever a
%response from a child to the parent is in transit, the parent can not send any
%response to the child, or it will violate Invariant \fullref{noCross}. Using the fact that 
%
%
%
%
%
%
%
%\begin{inv}
%\textit{inTransitCondition}:
%\begin{enumerate}
%\item When a response is sent from a child $c$ at time $t$ for an address $a$,
%and has not been received by the parent $p$ before time $t'$, $\forall t_i, t <
%t_i \le t' @-> c.\state[a]$ at $t_i \le c.\state[a]$ at $t+1$ and $\forall t_i,
%t \le t_i \le t' @->$ $p.\dstate[c][a]$ at $t_i \ge c.\state[a]$ at $t$.
%\item When a response is sent from parent $p$ at time $t$ for an address $a$,
%and has not been received by its child $c$ before time $t'$, $\forall t_i, t <
%t_i \le t' @-> p.\dstate[c][a]$ at $t_i \ge p.\dstate[c][a]$ at $t+1$ and
%$\forall t_i, t \le t_i \le t' @->$ $c.\state[a]$ at $t_i \le p.\dstate[c][a]$ at
%$t$.
%\end{enumerate}
%\label{inTransitCondition}
%\end{inv}
%
%\begin{inv}
%\textit{prevState}: When a response is received from a child to the parent
%(parent to child) for an address, the state of the child for that address at
%the time of sending (receiving) the response is the same as the parent's
%directory for that child and address at the time of receiving (sending) the
%response.
%\label{prevState}
%\end{inv}
%
%
%
%%Top
%%a) conservative: forall p c a t, parent c p -> dir p c a t >= state c a t
%%b) forall p c a t, parent c p -> state p a t >= dir p c a t
%%c) forall c1 c2 a t, sibling c1 c2 -> compatible c1 c2 a t
%%d) nextClean: ~ clean c a t -> clean c a (S t) -> exists s d ts, recv data s a t d /\ send data s a ts d /\ clean s a ts /\ ts <= t /\ forall ti, ts <= ti < t ->  ~ write a ti
%%
%%(from=state(t1)=dir(t2) -> betweenPSendCRecv:dir(t)>=to&state(t)<=from, betweenCSendPRecv:state(t)<=to&dir(t)>=from), noMesgImp:state(t)=dir(t) -> conservative (ignore from=, use only a, b)
%%a) Child sends message iff it downgrades
%%b) Parent sends message iff it upgrades
%%c) State is changed only on sending or receiving a message
%%d) FIFO messages
%%e) cross: Message from child and parent do not cross
%%
%%cross:
%%a) parent send message only on receiving request
%%b) req from child does not overtake response from child (prove using the from states)
%%c) resp from parent does not overtake request from parent
%%d) voluntary response sent from child only when not waiting
%%
%%In this section we specify a set of important invariants for a parent-child pair of caches.

%%  LocalWords:  Invariants invariants
