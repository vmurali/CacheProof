\section{Intuition}

In this section we give the proof of the MSI cache coherence protocol. We give
the proof in a top-down fashion starting with the store atomicity theorem. We
specify important invariants and show how they are proved in the MSI protocol.
In Section \ref{Refinements} show how these invariants hold in other protocols
like MESI and MOSI. These invariants are true at each step in the (infinite)
list of transitions starting from the initial state. We use the term time $t$
to specify the global state reached after $t$ transitions.  All the invariants
below pertain to a particular address; we will implicitly assume a universal
quantification over all address as a prefix to each of the invariants (if not
explicitly mentioned).

\subsection{Top invariants}
\begin{defn}
\textit{clean}: A cache is said to be \clean{} for an address iff the state of the
cache is at least \Sh{} and the state of all its children is at most \Sh.
\end{defn}
\begin{inv}
At any time $t$, a cache $c$ which is clean for an address $a$ will have the most
up-to-date value for that address, \ie
\begin{enumerate}
\item $c.\data[a] = \initData(a)$ and no store request has been processed at
any time $< t$, or
\item There is a store request $q$ that was processed at time $t'$ such that
$t' < t$ and $a = q.\addrQ \wedge c.\data[a] = q.\dataQ$ and no other store
request $q'$ was processed at any time $t_i$ such that $t' < t_i < t \wedge a =
q'.\addrQ$.
\end{enumerate}
\label{latestValue}
\end{inv}

The following invariants hold for leaf caches.
\begin{inv}
\textit{uniqM}: At all times, at most one leaf cache can be in \Mo{} state.
\label{uniqM}
\end{inv}

\begin{inv}
\textit{processReq}: At all times, a load or a store request at a leaf cache can be processed
only if it is at least in \Sh{} or \Mo{} state at that time, respectively.
\label{processReq}
\end{inv}

\begin{inv}
\textit{noReqAgain}: A leaf cache $c$ processes the $c.\pos^{th}$ request iff
$c.\pos$ changes. $c.\pos$ only gets incremented when it changes.
\label{noReqAgain}
\end{inv}

Using Invariants \ref{latestValue} to \ref{noReqAgain}, it is easy to see that
Theorem \textit{storeAtomicity} can be proved. Since a store can happen only
when the state of a leaf cache is in \Mo{} state (Invariant
\textit{processReq}), because of Invariant \textit{uniqM} only one store
request can be processed at a time throughout the system, thereby satisfying
\textit{uniqStTimes}. Because of Invariant \textit{noReqAgain}, once a response
has been produced for a request $i$, the cache can only process requests $j, j
> i$. Thus there is at most one response to each request, satisfying
\textit{uniqRespLabels}. A load request can be processed only if a cache is at
least in \Sh{} state according to Invariant \textit{processReq}.  When a leaf
cache is at least in \Sh{} state, since it has no children, it is \clean{}.
Thus, by Invariant \textit{lastestValue}, the final condition for Theorem
\textit{storeAtomicity} is satisfied.

Note that Invariants \textit{processReq} and \textit{noReqAgain} can be proved
directly from the atomic transitions describing the system (Figure \ref{trans}
for MSI; other protocols must also have similar transitions). Proving Invariants
\textit{uniqM} and \textit{latestValue} requires the following invariants.

\begin{inv}
\textit{conservative}: At all times, the state of a cache is not greater than
its parent's directory corresponding to the cache.
\label{conservative}
\end{inv}

\begin{inv}
\textit{stateCompat}: At all times, the state of a cache is not less than its
directory corresponding to any of its children.
\label{stateCompat}
\end{inv}

We use the definition of compatibility between two caches as follows:
\begin{defn}
\textit{compatibile}: At some time, cache $c_1$ is compatible with $c_2$ iff
at that time,
\begin{enumerate}
\item $c_1.\state[a] = \In$ whenever $c_2.\state[a] = \Mo$ and
\item $c_1.\state[a] \le \Sh$ whenever $c_2.\state[a] = \Sh$
\end{enumerate}
\label{compatible}
\end{defn}

\begin{inv}
\textit{siblingCompat}: At all times, two sibling caches (\ie caches with the
same parent) are compatible.
\label{siblingCompat}
\end{inv}

\begin{inv}
\textit{noTransitWrite}: When a cache $c$ transitions from non-clean at time
$t$ to clean at time $t+1$ for an address $a$, then it receives data $a$ from
some cache $s$ such that the $s$ is clean at the time $t'$ for address $a$, and
no store request was processed for $a$ at time $t_i$ such that $t' \le t_i \le
t$.
\label{noTransitWrite}
\end{inv}

For any two caches $c$ and $p$, such that $c$ is a descendent of $p$ in the cache
hierarchy (the descendent relation between two caches is the transitive
reflexive closure of the parent relation), from Invariants
\textit{conservative} and \textit{stateCompat}, it is clear that for any
address $a$, $c.\state[a] \le p.\state[a]$. Any two caches $c_1, c_2$ in which
neither is the decendent of the other will have a lowest common ancestor $x$
such that both the caches are descendents of $x$ and $c_1, c_2$ are descendents
of distinct caches $x_1, x_2$, respectively, such that $x_1, x_2$ are children
of $x$. $x_1$ and $x_2$ are compatible because of Invariant
\textit{siblingCompat}. $c_1.\state[a] \le x_1.\state[a]$ and
$c_2.\state[a] \le x_2.\state[a]$ because of Invariants \textit{conservative}
and \textit{stateCompat}. From this, it can easily be seen from the definition
of compatible that $c_1$ and $c_2$ are compatible whenever $x_1$ and $x_2$ are
compatible. From the definition of compatible it can be seen that both caches can not
be in the \Mo{} state for them to be compatible. This directly proves Invariant
\textit{uniqM}.

Invariant \textit{latestValue} can be proved using induction on time. Let us
assume that all caches which are clean at time $t'$ such that $t'<t+1$ have the
latest value. If a cache $c$ is clean at time $t$, then none of its descendents
are in \Mo, and hence none of its descendents can process a store request at
$t$. Any non descendent is compatible with it (as shown in the previous
paragraph) and so no non-descendent cache can be in \Mo, since a clean cache is
at least in \Sh. So only $c$ can process a store request at $t$ (assuming $c$
is a leaf cache and is in state \Mo) when it is clean, and no other cache can
process a store request. By induction hypothesis, it contained the latest value
at time $t$ which remains true (because of no processing of store request) at
time $t+1$. Now, if a cache was not clean at time $t$, then it would have
received the data from some cache which was clean at the time of sending the
data (by Invariant \textit{noTransitWrite}), which means the data is the latest
value by induction hypothesis, so the new data it receives at time $t$ is the
latest value, making the clean cache at time $t+1$ have the latest value.

Invariant \ref{conservative} can be proved by
further breaking them into the following invariants between a parent-child pair
of caches.

\begin{inv}
\textit{stateChange}:
\begin{enumerate}
\item A child sends a response to its parent iff it downgrades its state.
\item A parent sends a response to a child iff it upgrades the directory of
that child.
\item The state and the directory can change only on sending and receiving a
response.
\end{enumerate}
\label{stateChange}
\end{inv}

Invariant \textit{stateChange} can be proved directly from the atomic
transitions for MSI. Other protocols have similar atomic transitions obeying
these invariants.

\begin{inv}
\textit{inTransitChange}:
\begin{enumerate}
\item When a response is sent from a child $c$ at time $t$ for an address $a$,
and has not been received by the parent $p$ before time $t'$, $\forall t_i, t <
t_i \le t' @-> c.\state[a]$ at $t_i \le c.\state[a]$ at $t+1$ and $\forall t_i,
t \le t_i \le t' @->$ $p.\dstate[c][a]$ at $t_i \ge c.\state[a]$ at $t$.
\item When a response is sent from parent $p$ at time $t$ for an address $a$,
and has not been received by its child $c$ before time $t'$, $\forall t_i, t <
t_i \le t' @-> p.\dstate[c][a]$ at $t_i \ge p.\dstate[c][a]$ at $t+1$ and
$\forall t_i, t \le t_i \le t' @->$ $c.\state[a]$ at $t_i \le p.\dstate[c][a]$ at
$t$.
\end{enumerate}
\label{inTransitChange}
\end{inv}

\begin{inv}
\textit{noTransitEqual}: When no response is in transit for an address, then
the state of a cache for that address is the same as its parent's directory for
that cache and address.
\label{noTransitEqual}
\end{inv}

Using Invariants \ref{stateChange} to \ref{noTransit}, it is easy to prove
Invariant \ref{conservative}. If no response is in flight for an address, then
the parent's directory state of the cache for the address matches that of the
cache's state for that address. If there is a response from parent to child in
flight, then the corresponding directory at the parent will be no less than the
directory immediately after the response was sent and the state of the child
will be no greater than the directory immediately before the response was sent
(by Invariant \textit{inTransitChange}). By Invariant \textit{stateChange}, the
parent upgrades the directory when sending the response, thus conforming to
Invariant \textit{conservative}. Similarly, it can be shown that if there is a
response from child to parent, Invariant \textit{coservative} will hold.

\begin{inv}
\textit{prevState}: When a response is received from a child to the parent
(parent to child) for an address, the state of the child for that address at
the time of sending (receiving) the response is the same as the parent's
directory for that child and address at the time of receiving (sending) the
response.
\label{prevState}
\end{inv}

%Top
%a) conservative: forall p c a t, parent c p -> dir p c a t >= state c a t
%b) forall p c a t, parent c p -> state p a t >= dir p c a t
%c) forall c1 c2 a t, sibling c1 c2 -> compatible c1 c2 a t
%d) nextClean: ~ clean c a t -> clean c a (S t) -> exists s d ts, recv data s a t d /\ send data s a ts d /\ clean s a ts /\ ts <= t /\ forall ti, ts <= ti < t ->  ~ write a ti
%
%(from=state(t1)=dir(t2) -> betweenPSendCRecv:dir(t)>=to&state(t)<=from, betweenCSendPRecv:state(t)<=to&dir(t)>=from), noMesgImp:state(t)=dir(t) -> conservative (ignore from=, use only a, b)
%a) Child sends message iff it downgrades
%b) Parent sends message iff it upgrades
%c) State is changed only on sending or receiving a message
%d) FIFO messages
%e) cross: Message from child and parent do not cross
%
%cross:
%a) parent send message only on receiving request
%b) req from child does not overtake response from child (prove using the from states)
%c) resp from parent does not overtake request from parent
%d) voluntary response sent from child only when not waiting
%
%In this section we specify a set of important invariants for a parent-child pair of caches.
