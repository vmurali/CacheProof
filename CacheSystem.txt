State is a type containing a total-ordered set of possible coherence states (Eg: in MSI, M > S > I)

Required elements per node per block:
-------------------------------------
Directory (dir) : Vector of State, one element for each child of the node, representing assumed State of the child
Summary (summ) : State, representing the overall state of a node ( a summary of the directory )
Summary Busy (summBusy): Bool, representing if a request has been sent to the parent
Directory Next (dirNext) : Vector of Maybe State, one element for each child of the node. It represents the next State the node is waiting a child to become, in case it has sent a request.

Network:
--------
1. One (virtual) link from parent to child for both requests and responses
2. One (virtual) link from child to parent for responses
3. One (virtual) link from child to parent for requests
4. Child to parent response link has higher priority over child to parent request link, ie., child to parent request arrives at a parent earlier than child to parent response => the request was sent by the child earlier.

Notation for the following rules:
---------------------------------
p is the parent. x, y, x', y' are values of type State. The conditions in the guards written inside [] is assured to be true. summOk(x, summ) is a protocol-dependent function checking if the summary state is compatible with one of the child's directory element of x. restDirOk(c,y, dir) is a protocol-dependent function checking if the rest of the directory is compatible with a child being in state y. dirOk(x, dir) is a protocol-dependent function checking if the directory is compatible with summary state of x.


Summary Manipulation rules:
---------------------------
---------------------------

Child sending response to parent:
---------------------------------

summ = x && !summBusy && y < x && dirOk(y, dir)
=> to.p.resp(y)
   summ := y

summ = x && from.p.req = y && y >= x
=> p.req.deq

summ = x && from.p.req = y && y < x && y' <= y && dirOk(y', dir)
=> p.req.deq
   to.p.resp := y'
   summ := y'


Child sending request to parent:
--------------------------------
summ = x && y > x && !summBusy
=> summBusy := True
   to.p.req := y


Child receiving response from parent:
-------------------------------------
summ = x && from.p.resp = y [&& y > x && summBusy]
=> summBusy := False
   p.resp.deq
   summ := y


Directory Manipulation rules:
-----------------------------
-----------------------------

Parent receiving request from child:
------------------------------------
dir.c = x && from.c.req = y && restDirOk(c, y, dir) && summOk(y, summ) (&& y > x)
=> dir.c := y
   from.c.req.deq
   to.c.resp := y

Parent sending request to child:
--------------------------------
dir.c = x && y < x && !dirBusy.c
=> dirNext.c := Just y
   to.c.req := y

Parent receiving response from child:
-------------------------------------
from.c.resp = y && (dirNext.c = Nothing || dirNext.c = Just y' && y > y') [&& dir.c = x && y < x]
=> dir.c := y
   from.c.resp.deq

from.c.resp = y && dirNext.c = Just y' && y <= y' [&& dir.c = x && y < x]
=> dir.c := y
   from.c.resp.deq
   dirNext.c := Nothing

Theorems:
---------
1. dir.c = x and c.summ = y => x > y
2. When a child c sends a response z to parent (to.p.resp = z) while c.summ changes from y, and when the parent receives that response, dir.c changes from x => x = y
3. When a parent processes a request for z (from.c.req = z), c.summ = y and dir.c = x => x = y

This ensures that
1. the parent has a conservative estimate of the summary state of the child
2. when a parent processes a request, the state the parent assumes the child to be in (via it's directory) is the correct state of the child
3. when a response is sent, the sender knows exactly which state the receiver of the response would be in when it receives the response, hence co-ordinating data transfer correctly
4. the above rules handle all possible scenarios that might arise

Liveness property:
------------------
------------------
Protocol properties:
--------------------
for all x, dir, there exists dir' <= dir, dirOk(x, dir')
for all x, dir, there exists dir' <= dir, restDirOk(c, x, dir')
for all x, summ, there exists summ' <= summ, summOk(x, summ')

Buffering properties:
---------------------
1. 1 virtual channel between two levels for parent to child messages
2. 1 virtual channel between two levels for child to parent requests
3. 1 virtual channel overall for child to parent responses
4. 1 buffer in each of the virtual channels

Node property:
--------------
The internal nodes are such that no request is left to starve.

Theorem: If these properties are obeyed, then the protocol will not deadlock.

Protocols that can be implemented:
----------------------------------
----------------------------------

MSI:
----
State = M > S > I
summ = M =>
    dir.c = M => for all x \= c, dir.x = I, data present in subtree rooted by c
    otherwise, data present in node

summ = S =>
    for all c, dir.c <= S, data present in node

summ = I =>
    for all c, dir.c = I, data not present in subtree rooted by node

Child to parent request: M req, S req
Parent to child response: (S to M) M resp, (I to M) M resp data, (I to S) S resp data
Parent to child request: S req, I req
Child to parent response: (M to S) S resp data, (M to I) I resp data (voluntary), (S to I) I resp (voluntary)

// Should describe dirOk etc, and how to reach that.

MOSI:
-----
Variation with cache intervention.
State = M > O > SI > S > I
summ = M =>
    dir.c = M => for all x \= c, dir.x = I, data owned in subtree rooted by c
    dir.c = O => for all x \= c, dir.x <= SI, data owned in subtree rooted by c
    otherwise, data owned in node

summ = O =>
    dir.c = O => for all x \= c, dir.x <= SI, data owned in subtree rooted by c
    otherwise, data owned in node

summ = SI =>
    for all c, dir.c <= SI, data possibly present in subtree rooted by c

summ = S =>
    for all c, dir.c <= S, data present in node

summ = I =>
    for all c, dir.c = I, data not present in subtree rooted by node

Child to parent request: M req, S req
Parent to child response: (O to M) M resp, (S to M) M resp, (I to M) M resp data, (I to S) S resp data
Parent to child req: (M) O req send, I req send, no req send, I req no send
Child to parent response: O resp sent, I resp no sent data, I resp sent, sent
