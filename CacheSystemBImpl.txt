MSI for hierarchical directory:

Cache-coherence is enforced at block level and a block is a set of contiguous addresses.

State of a block in a cache: {M,S,I}
The states are ordered: M > S > I

Each node maintains the following state for each block:
------------------------------------------------------
state    :: State
         // The state of a block in the node
dir      :: [State]
         // The state of each of the children
waitP    :: Bool
         // True iff a request has been sent to the parent and
            a response has not been received
dirWaitC :: [Maybe State]
         // One element for each child of the node. It represents if a
            request has been sent to set the child to the specified state
            and a response has not been received

node is n
p = n.parent
p.children = set of children of p

restDirOk(c, M, dir) = for all x in dir and x \= c, dir.x = I
restDirOk(c, S, dir) = for all x in dir and x \= c, dir.x <= S

I to M (cache write)
--------------------
max(p.dir) = I
____________________________________________
n.state := M; p.dir.n := M; n.data := p.data

This is an upgrade. It involves request from child, response from parent and final upgrade by child:

Req from child:
n.state = I && !n.waitP
______________________________________
n.waitP := True; n.reqToParent := M

Response from parent:
p.dir.n = I && p.reqFromChild(n) = M && max(p.dir) = I
__________________________________________________________________
p.dir.c := M; p.reqFromChild(c).deq; p.respToChild(c) := (M, data)

Upgrade by child:
n.state = I && n.respFromParent = (M, data) [Implicit: n.waitP]
____________________________________________________________________
n.waitP := False; n.respFromParent.deq; n.state := M; n.data = data



I to S (cache read)
-------------------
max(p.dir) = S
________________________________________________
n.state := S; p.dir.n := S; n.data := p.data

This is an upgrade. It involves request from child, response from parent and final upgrade by child:

Req from child:
n.state = I && !n.waitP
______________________________________
n.waitP := True; n.reqToParent := S

Response from parent:
p.dir.n = I && p.reqFromChild(n) = S && max(p.dir) <= S
____________________________________________________________________
p.dir.c := S; p.reqFromChild(c).deq; p.respToChild(c) := (S, data)

Upgrade by child:
n.state = I && n.respFromParent = (S, data) [Implicit: n.waitP]
___________________________________________________________________
n.waitP := False; n.respFromParent.deq; n.state := S; n.data = data



M to S (writeback)
------------------
n.state = M [Implicit: dir.n = M && for all x in p.dir and x \= n, dir.x = I]
_____________________________________________________________________________
n.state := S; p.dir.n := S; p.data := n.data

This is a downgrade. It involves either request from parent, response from child and final downgrade by parent. The response from child can be voluntary also. Because of the voluntary responses, there can be a semi-downgrade (where the parent is waiting for an I resp and instead it gets an S resp). The request from the parent can also be previously satisfied, in which case child drops the request.

Req from parent:
p.dir.n = M && p.dirWaitC.n = Nothing
____________________________________________
p.dirWaitC.n := Just S; p.reqToChild(n) := S

Child drops request:
n.state = S && n.reqFromParent = S
__________________________________
n.reqFromParent.deq

Voluntary Resp from child:
n.state = M && !n.waitP && S >= max(n.dir)
____________________________________________
n.respToParent := (S, data); n.state := S

Resp from child:
n.state = M && n.reqFromParent = S && S <= max(n.dir)
______________________________________________________________
n.reqFromParent.deq; n.respToParent := (S, data); n.state := S

Voluntary resp from child downgrade by parent:
p.dir.c = M && p.respFromChild(n) = (S, data) && (p.dirWaitC.n = Nothing || p.dirWaitC.n = Just I)
__________________________________________________________________________________________________
p.dir.c := S; p.respFromChild(n).deq; p.data := data

Full Downgrade by parent:
p.dir.n = m && p.respfromchild(n) = (s, data) && p.dirwaitc.n = just s
_____________________________________________________________________________
p.dir.n := s; p.respfromchild(n).deq; p.dirwaitc.n := nothing; p.data := data



S to I (invalidate)
-------------------
n.state = S [Implicit: dir.n && max(p.dir) = S]
_______________________________________________
n.state := I; p.dir.n := I

This is a downgrade. It involves either request from parent, response from child and final downgrade by parent. The response from child can be voluntary also. The request from the parent can also be previously satisfied, in which case child drops the request.

Req from parent:
p.dir.n = S && p.dirWaitC.n = Nothing
____________________________________________
p.dirWaitC.n := Just I; p.reqToChild(n) := I

Child drops request:
n.state = I && n.reqFromParent = I
__________________________________
n.reqFromParent.deq

Voluntary Resp from child:
p.state = S && !n.waitP && I >= max(n.dir)
____________________________________________
n.respToParent := I; n.state := I

Resp from child:
n.state = S && n.reqFromParent = I && I <= max(n.dir)
______________________________________________________
n.reqFromParent.deq; n.respToParent := I; n.state := I

Voluntary resp from child downgrade by parent:
p.dir.c = S && p.respFromChild(n) = I && p.dirWaitC.n = Nothing
_______________________________________________________________
p.dir.c := I; p.respFromChild(n).deq;

Full Downgrade by parent:
p.dir.n = S && p.respFromChild(n) = I && p.dirWaitC.n = Just I
______________________________________________________________
p.dir.n := I; p.respFromChild(n).deq; p.dirWaitC.n := Nothing
