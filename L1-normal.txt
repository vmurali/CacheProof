req from parent:
input: pIndex, lineAddr, to
let present = getPresent(lineAddr)
let index = getIndex(lineAddr)
accept: True
if(present)
  let (State st) = state[index]
  if(st > to)
    state[index] <= State to
    p.resp(Index pIndex, to, dirty[index], line[index])

handleCoreReq(to, cmd, data, byteEn, index, offset, inState)
  let (State st) = inState
  if(st < to)
    let mshrptr <- mshr.insert(Mshr cmd data byteEn offset)
    state[index] <= Coherence {PReq} mshrptr
    p.req(index, lineAddr, st -> to)
  else
    line.updateData(cmd, data, byteEn, index, offset)
    resp(morph(cmd, data, byteEn, line[index][offset]))

req from core:
input: addr, to, cmd, data, byteEn
let present = getPresent(addr)
let index = getIndex(addr)
let lineAddr = getLineAddr(addr)
accept: ~isPReq[index] /\ (present \/ existsReplace[lineAddr])
let offset = getOffset(addr)
if(present)
  handleCoreReq(to, cmd, data, byteEn, index, offset, inState)
else
  let (replaceLineAddr, replaceIndex) = getReplace[lineAddr]
  let (State st) = state[replaceIndex]
  if(st <> I)
    tag[replaceIndex] <= getTag(lineAddr)
    p.resp(Voluntary replaceLineAddr, I, dirty[replaceIndex], line[replaceIndex])
  handleCoreReq(to, cmd, data, byteEn, index, offset, State I)

resp from parent:
input: index, from -> gotTo, lineIn
if(dataFromParent(from, gotTo))
  line[index] <= lineIn
let (Coherence whoState mshrptr) = state[index]
let (Mshr cmd data byteEn offset) = mshr.get(mshrptr)
mshr.remove(mshrptr)
state[index] <= State gotTo
line.updateData(cmd, data, byteEn, index, offset)
resp(morph(cmd, data, byteEn, line[index][offset]))
