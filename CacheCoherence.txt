Setup

----------------------------------

Each cache c has the following states:
  c.state : Denotes the real state of this cache
  c.child[i].state : Denotes the assumed state of i^th child of this cache
  c.wait : Denotes a tuple of (response from the parent the cache is waiting for and a child to "process" after the response comes back), or Nothing if cache is not waiting for a response from parent
  c.child[i].wait : Denotes which response from the i^th child the cache is waiting for, or Nothing if cache is not waiting for a response from the i^th child
  c.child[i].sendReq : Denotes which request the cache has to send its i^th child, or Nothing if cache is not going to send any request to the i^th child

  c.reqTo : The request buffer to the parent
  c.respTo : The response buffer to the parent
  c.From: The buffer from the parent (both request and response)

  c.child[i].To : The buffer to the i^th child (both request and response)
  c.child[i].reqFrom : The request buffer from the i^th child
  c.child[i].respFrom : The response buffer from the i^th child

  c.token : This specifies which of the transactions to fire - ensure fair arbitration and completion of an existing transaction

  It takes indeterminate time for a message to reach from any node to any other node.
  The c.From (which is the same as the c.child[i].To) network has FIFO order.
  The c.respTo (which is the same as c.child[i].respFrom) network has FIFO order.
  The c.reqTo (which is the same as c.child[i].reqFrom) network need not have FIFO order.

  In the description, the presence of resources/presence of a message in the FIFO is implicit - the corresponding group of actions (within the if-block) wouldn't fire if the implicit conditions are not met.

----------------------------------

Initialization

----------------------------------

if c is the i^th child of p, c.state = p.child[i].state
if r is the root of the tree, r.state = Max State

----------------------------------

Helper functions

----------------------------------

Precondition: y < c.state
Action Send_Response_To_Parent(c, y):
  c.respTo := y
  c.state := y

Precondition: y > c.child[n].state
Action Send_Response_To_Child(c, n, y):
  c.child[n].To := Resp (c.child[n].state)->y
  c.child[n].state := y

Precondition: c.From == Resp x->y
Action Receive_Response_From_Parent(c):
  if(x <= c.state)
    c.state := y
  c.From.deq

Action Receive_Response_From_Child(c, n):
  c.child[n].state := c.child[n].respFrom
  c.child[n].respFrom.deq

Bool No_Child_Pending(c) = forall i, c.child[i].wait == Nothing && c.child[i].sendReq == Nothing

Precondition: No_Child_Pending(c)
Action Downgrade(c, y):
  if(forall i, c.child[i].state <= y)
    Send_Response_To_Parent(c, y)
  else
    forall i,
      if(c.child[i].state > y)
        c[child[i].sendReq := y

Precondition: c.wait == Nothing && No_Child_Pending(c)
Action Upgrade(c, n, y):
  if(c.state >= y && forall i != n, c.child[i].state <= Get_Compatible(y))
    Send_Response_To_Child(c, n, y)
  else if(c.state < y)
    c.reqTo := y
    c.wait := (y, n)
    c.token := Nothing
  else
    forall i != n,
      if(c.child[i].state > Get_Compatible(y))
        c.child[i].sendReq := Get_Compatible(y)

----------------------------------

Behavior(c):

# Receive_Response_From_Child_Rule(n):
  if(c.child[n].wait >= c.child[n].respFrom)
    c.child[n].wait := Nothing
  Receive_Response_From_Child(c, n)

# Receive_Response_From_Parent_Rule:
  if(c.From == Resp _ && c.wait == Nothing)
    Receive_Response_From_Parent(c)

# Drop_Send_Request(n):
  if(c.child[n].sendReq != Nothing && c.child[n].state <= c.child[n].sendReq)
    c.child[n].sendReq := Nothing

# Do_Send_Request(n):
  if(c.child[n].wait == Nothing && c.child[n].sendReq != Nothing && c.child[n].state > c.child[n].sendReq)
    c.child[n].wait := c.child[n].sendReq
    c.child[n].To := Req c.child[n].sendReq
    c.child[n].sendReq := Nothing

##################################

# Voluntary_Downgrade(y):
  if(c.wait == Nothing && c.token == Voluntary_Downgrade y && No_Child_Pending(c))
    if(c.state <= y)
      c.token := Nothing
    else Downgrade(c, y)

# Receive_Request_From_Parent:
  if(c.From == Req y && c.token == Receive_Request_From_Parent && No_Child_Pending(c))
    if(c.state <= y)
      c.token := Nothing
      c.From.deq
    else Downgrade(c, y)

# Voluntary_Upgrade(n, y):
  if(c.wait == Nothing && c.token == Voluntary_Upgrade n y && No_Child_Pending(c))
    if(c.child[n].state >= y)
      c.token := Nothing
    else Upgrade(c, n, y)

# Receive_Request_From_Child(n):
  if(c.wait == Nothing && c.token == Receive_Request_From_Child n && No_Child_Pending(c))
    if(c.child[n].state >= c.child[n].reqFrom)
      c.token := Nothing
      c.child[n].reqFrom.deq
    else Upgrade(c, n, c.child[n].reqFrom)

# Receive_Response_From_Parent_For_Request_Rule:
  if(c.From == Resp x->y && c.wait == (z, n) && c.token == Receive_Response_From_Parent_For_Request && No_Child_Pending(c))
    Receive_Response_From_Parent(c)
    if(z <= y)
      c.wait := Nothing
      c.token := Receive_Request_From_Child n
    else
      c.token := Nothing

##################################

# Scheduler:
  if(c.token == Nothing)
    if(c.wait != Nothing)
      if(c.respTo.exists)
        c.token := Receive_Response_From_Parent_For_Request
      else if(c.reqTo.exists)
        c.token := Receive_Request_From_Parent
    else if(Replacement)
      c.token := Voluntary_Downgrade (Min State)
    else
      c.token := Weak_Fair_Scheduling_Result

----------------------------------

Correctness Theorem:
  Consider two caches p, c such that c is the n^th child of p. Consider two time-points P and Q, such that
     a) x = c.state at time P is *not* as a result of an upgrade response sent by the parent *after* Q. (Instead it is because of an upgrade request sent before Q. Any number of downgrade responses can be sent from the child to the parent after it has received the upgrade response from the parent).
     b) y = p.child[n].state at time Q is *not* as a result of a downgrade response sent by the child *after* P. (Instead it is because of a downgrade request sent before P. Any number of upgrade responses can be sent from the parent to the child after it has received the downgrade response from the child).
  Then x <= y

Correctness Corollary:
  For two caches p, c such that c is the n^th child of p, at any time instant c.state <= p.child[n].state

----------------------------------

Coherence Theorem:
  a) forall i, c.state >= c.child[i].state
  b) forall i j, c.child[i].state <= Get_Compatible(c.child[j].state) || c.child[j].state <= Get_Compatible(c.child[i].state)

----------------------------------

From-Child-Response-Consumed Theorem:
  Any response from any child will be dequeued eventually by the parent

----------------------------------

From-Parent-Req-Resp-Consumed Theorem:
  Any request or response from any parent will be dequeued eventually by the child

----------------------------------

From-Child-Req-Consumed Theorem:
  Any request from any child will be dequeued eventually by the parent

----------------------------------

If-Request-Dequeued-Request-Response-Pairing Theorem:

Lemma 1 On sending a request, the sender goes into a wait state

Lemma 2 The wait state of a request can be cleared only on getting the corresponding response

Stmt: If a request is dequeued, then the request's corresponding wait state will be cleared

Corollary Theorem:
  A node, on sending a request, goes into a wait state which will be eventually cleared by getting the corresponding response
